// tslint:disable
/**
 * Blockchain.com Exchange REST API
 * ## Introduction Welcome to Blockchain.com\'s Exchange API and developer documentation. These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account Select API from the drop down menu Fill out form and click “Create New API Key Now” Once generated you can view your keys under API Settings 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    currency: string;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    balance: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    available: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    balance_local: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    available_local: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    rate: number;
}
/**
 * 
 * @export
 * @interface BalanceMap
 */
export interface BalanceMap {
    [key: string]: Array | any;

    /**
     * 
     * @type {Array<Balance>}
     * @memberof BalanceMap
     */
    primary: Array<Balance>;
}
/**
 * 
 * @export
 * @interface BaseOrder
 */
export interface BaseOrder {
    /**
     * Reference field provided by client and cannot exceed 20 characters
     * @type {string}
     * @memberof BaseOrder
     */
    clOrdId: string;
    /**
     * 
     * @type {OrdType}
     * @memberof BaseOrder
     */
    ordType: OrdType;
    /**
     * Blockchain symbol identifier
     * @type {string}
     * @memberof BaseOrder
     */
    symbol: string;
    /**
     * 
     * @type {Side}
     * @memberof BaseOrder
     */
    side: Side;
    /**
     * The order size in the terms of the base currency
     * @type {number}
     * @memberof BaseOrder
     */
    orderQty: number;
    /**
     * 
     * @type {TimeInForce}
     * @memberof BaseOrder
     */
    timeInForce?: TimeInForce;
    /**
     * The limit price for the order
     * @type {number}
     * @memberof BaseOrder
     */
    price?: number;
    /**
     * expiry date in the format YYYYMMDD
     * @type {number}
     * @memberof BaseOrder
     */
    expireDate?: number;
    /**
     * The minimum quantity required for an IOC fill
     * @type {number}
     * @memberof BaseOrder
     */
    minQty?: number;
    /**
     * The limit price for the order
     * @type {number}
     * @memberof BaseOrder
     */
    stopPx?: number;
}
/**
 * 
 * @export
 * @interface CancelOrderRequest
 */
export interface CancelOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof CancelOrderRequest
     */
    action: CancelOrderRequestActionEnum;
    /**
     * The unique order id assigned by the exchange
     * @type {number}
     * @memberof CancelOrderRequest
     */
    orderID: number;
}

/**
    * @export
    * @enum {string}
    */
export enum CancelOrderRequestActionEnum {
    CANCELORDERREQUEST = 'CancelOrderRequest'
}

/**
 * 
 * @export
 * @interface CreateWithdrawalRequest
 */
export interface CreateWithdrawalRequest {
    /**
     * The amount to withdraw in the currency specified
     * @type {number}
     * @memberof CreateWithdrawalRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof CreateWithdrawalRequest
     */
    beneficiary: string;
    /**
     * If set, sends the full available amount, minus fees. Amount may not be specified in that case. 
     * @type {boolean}
     * @memberof CreateWithdrawalRequest
     */
    sendMax?: boolean;
}
/**
 * 
 * @export
 * @interface DepositAddressCrypto
 */
export interface DepositAddressCrypto {
    /**
     * 
     * @type {string}
     * @memberof DepositAddressCrypto
     */
    type: string;
    /**
     * Address to deposit to. If a tag or memo must be used, it is separated by a colon.
     * @type {string}
     * @memberof DepositAddressCrypto
     */
    address: string;
}
/**
 * 
 * @export
 * @interface DepositInfo
 */
export interface DepositInfo {
    /**
     * Unique ID for this withdrawal
     * @type {string}
     * @memberof DepositInfo
     */
    depositId: string;
    /**
     * The amount that is credited in the currency specified
     * @type {number}
     * @memberof DepositInfo
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof DepositInfo
     */
    currency: string;
    /**
     * Address to deposit to. If a tag or memo must be used, it is separated by a colon.
     * @type {string}
     * @memberof DepositInfo
     */
    address: string;
    /**
     * The transaction hash of the transaction that deposited funds
     * @type {string}
     * @memberof DepositInfo
     */
    txHash?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositInfo
     */
    state: DepositInfoStateEnum;
    /**
     * Time in ms since 01/01/1970 (epoch)
     * @type {number}
     * @memberof DepositInfo
     */
    timestamp?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DepositInfoStateEnum {
    REJECTED = 'REJECTED',
    UNCONFIRMED = 'UNCONFIRMED',
    COMPLETED = 'COMPLETED'
}

/**
 * 
 * @export
 * @interface Fees
 */
export interface Fees {
    /**
     * 
     * @type {number}
     * @memberof Fees
     */
    makerRate: number;
    /**
     * 
     * @type {number}
     * @memberof Fees
     */
    takerRate: number;
    /**
     * 
     * @type {number}
     * @memberof Fees
     */
    volumeInUSD: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrdType {
    MARKET = 'MARKET',
    LIMIT = 'LIMIT',
    STOP = 'STOP',
    STOPLIMIT = 'STOPLIMIT'
}

/**
 * 
 * @export
 * @interface OrderBook
 */
export interface OrderBook {
    /**
     * Blockchain symbol identifier
     * @type {string}
     * @memberof OrderBook
     */
    symbol?: string;
    /**
     * 
     * @type {Array<OrderBookEntry>}
     * @memberof OrderBook
     */
    bids?: Array<OrderBookEntry>;
    /**
     * 
     * @type {Array<OrderBookEntry>}
     * @memberof OrderBook
     */
    asks?: Array<OrderBookEntry>;
}
/**
 * 
 * @export
 * @interface OrderBookEntry
 */
export interface OrderBookEntry {
    /**
     * 
     * @type {number}
     * @memberof OrderBookEntry
     */
    px?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderBookEntry
     */
    qty?: number;
    /**
     * Either the quantity of orders on this price level for L2, or the individual order id for L3
     * @type {number}
     * @memberof OrderBookEntry
     */
    num?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderStatus {
    OPEN = 'OPEN',
    REJECTED = 'REJECTED',
    CANCELED = 'CANCELED',
    FILLED = 'FILLED',
    EXPIRED = 'EXPIRED'
}

/**
 * 
 * @export
 * @interface OrderSummary
 */
export interface OrderSummary {
    /**
     * The unique order id assigned by the exchange
     * @type {number}
     * @memberof OrderSummary
     */
    exOrdId?: number;
    /**
     * Reference field provided by client and cannot exceed 20 characters
     * @type {string}
     * @memberof OrderSummary
     */
    clOrdId: string;
    /**
     * 
     * @type {OrdType}
     * @memberof OrderSummary
     */
    ordType: OrdType;
    /**
     * 
     * @type {OrderStatus}
     * @memberof OrderSummary
     */
    ordStatus: OrderStatus;
    /**
     * 
     * @type {Side}
     * @memberof OrderSummary
     */
    side: Side;
    /**
     * The limit price for the order
     * @type {number}
     * @memberof OrderSummary
     */
    price?: number;
    /**
     * The reason for rejecting the order, if applicable
     * @type {string}
     * @memberof OrderSummary
     */
    text?: string;
    /**
     * Blockchain symbol identifier
     * @type {string}
     * @memberof OrderSummary
     */
    symbol: string;
    /**
     * The executed quantity for the order\'s last fill
     * @type {number}
     * @memberof OrderSummary
     */
    lastShares?: number;
    /**
     * The executed price for the last fill
     * @type {number}
     * @memberof OrderSummary
     */
    lastPx?: number;
    /**
     * For Open and Partially Filled orders this is the remaining quantity open for execution. For Canceled and Expired orders this is the quantity than was still open before cancellation/expiration. For Rejected order this is equal to orderQty. For other states this is always zero.
     * @type {number}
     * @memberof OrderSummary
     */
    leavesQty?: number;
    /**
     * The quantity of the order which has been filled
     * @type {number}
     * @memberof OrderSummary
     */
    cumQty?: number;
    /**
     * Calculated the Volume Weighted Average Price of all fills for this order
     * @type {number}
     * @memberof OrderSummary
     */
    avgPx?: number;
    /**
     * Time in ms since 01/01/1970 (epoch)
     * @type {number}
     * @memberof OrderSummary
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @interface PriceEvent
 */
export interface PriceEvent {
    /**
     * Blockchain symbol identifier
     * @type {string}
     * @memberof PriceEvent
     */
    symbol?: string;
    /**
     * 
     * @type {number}
     * @memberof PriceEvent
     */
    price_24h?: number;
    /**
     * 
     * @type {number}
     * @memberof PriceEvent
     */
    volume_24h?: number;
    /**
     * 
     * @type {number}
     * @memberof PriceEvent
     */
    last_trade_price?: number;
}
/**
 * 
 * @export
 * @interface PriceEventList
 */
export interface PriceEventList {
    /**
     * 
     * @type {Array<PriceEvent>}
     * @memberof PriceEventList
     */
    orders?: Array<PriceEvent>;
}
/**
 * \"buy\" for Buy, \"sell\" for Sell
 * @export
 * @enum {string}
 */
export enum Side {
    BUY = 'BUY',
    SELL = 'SELL'
}

/**
 * 
 * @export
 * @interface SymbolStatus
 */
export interface SymbolStatus {
    /**
     * Blockchain symbol identifier
     * @type {string}
     * @memberof SymbolStatus
     */
    base_currency?: string;
    /**
     * The number of decimals the currency can be split in
     * @type {number}
     * @memberof SymbolStatus
     */
    base_currency_scale?: number;
    /**
     * Blockchain symbol identifier
     * @type {string}
     * @memberof SymbolStatus
     */
    counter_currency?: string;
    /**
     * The number of decimals the currency can be split in
     * @type {number}
     * @memberof SymbolStatus
     */
    counter_currency_scale?: number;
    /**
     * The price of the instrument must be a multiple of min_price_increment * (10^-min_price_increment_scale)
     * @type {number}
     * @memberof SymbolStatus
     */
    min_price_increment?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolStatus
     */
    min_price_increment_scale?: number;
    /**
     * The minimum quantity for an order for this instrument must be min_order_size*(10^-min_order_size_scale)
     * @type {number}
     * @memberof SymbolStatus
     */
    min_order_size?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolStatus
     */
    min_order_size_scale?: number;
    /**
     * The maximum quantity for an order for this instrument is max_order_size*(10^-max_order_size_scale). If this equal to zero, there is no limit
     * @type {number}
     * @memberof SymbolStatus
     */
    max_order_size?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolStatus
     */
    max_order_size_scale?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolStatus
     */
    lot_size?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolStatus
     */
    lot_size_scale?: number;
    /**
     * Symbol status; open, close, suspend, halt, halt-freeze.
     * @type {string}
     * @memberof SymbolStatus
     */
    status?: SymbolStatusStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SymbolStatus
     */
    id?: number;
    /**
     * If the symbol is halted and will open on an auction, this will be the opening price.
     * @type {number}
     * @memberof SymbolStatus
     */
    auction_price?: number;
    /**
     * Opening size
     * @type {number}
     * @memberof SymbolStatus
     */
    auction_size?: number;
    /**
     * Opening time in HHMM format
     * @type {string}
     * @memberof SymbolStatus
     */
    auction_time?: string;
    /**
     * Auction imbalance. If > 0 then there will be buy orders left over at the auction price. If < 0 then there will be sell orders left over at the auction price.
     * @type {number}
     * @memberof SymbolStatus
     */
    imbalance?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum SymbolStatusStatusEnum {
    OPEN = 'open',
    CLOSE = 'close',
    SUSPEND = 'suspend',
    HALT = 'halt',
    HALT_FREEZE = 'halt-freeze'
}

/**
 * \"GTC\" for Good Till Cancel, \"IOC\" for Immediate or Cancel, \"FOK\" for Fill or Kill, \"GTD\" Good Till Date
 * @export
 * @enum {string}
 */
export enum TimeInForce {
    GTC = 'GTC',
    IOC = 'IOC',
    FOK = 'FOK',
    GTD = 'GTD'
}

/**
 * \"GTC\" for Good Till Cancel, \"GTD\" Good Till Date
 * @export
 * @enum {string}
 */
export enum TimeInForceStop {
    GTC = 'GTC',
    GTD = 'GTD'
}

/**
 * API key is missing or invalid
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
    /**
     * 
     * @type {string}
     * @memberof UnauthorizedError
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface WhitelistEntry
 */
export interface WhitelistEntry {
    /**
     * Unique ID for each whitelist entry
     * @type {string}
     * @memberof WhitelistEntry
     */
    whitelistId?: string;
    /**
     * User specified name for this entry
     * @type {string}
     * @memberof WhitelistEntry
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WhitelistEntry
     */
    currency?: string;
}
/**
 * 
 * @export
 * @interface WithdrawalInfo
 */
export interface WithdrawalInfo {
    /**
     * Unique ID for this withdrawal
     * @type {string}
     * @memberof WithdrawalInfo
     */
    withdrawalId?: string;
    /**
     * The amount to withdraw in the currency specified
     * @type {number}
     * @memberof WithdrawalInfo
     */
    amount: number;
    /**
     * The amount charged in fees for this withdrawal
     * @type {number}
     * @memberof WithdrawalInfo
     */
    fee?: number;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalInfo
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalInfo
     */
    beneficiary: string;
    /**
     * 
     * @type {WithdrawalStatus}
     * @memberof WithdrawalInfo
     */
    state?: WithdrawalStatus;
    /**
     * Time in ms since 01/01/1970 (epoch)
     * @type {number}
     * @memberof WithdrawalInfo
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawalStatus {
    REJECTED = 'REJECTED',
    PENDING = 'PENDING',
    REFUNDED = 'REFUNDED',
    FAILED = 'FAILED',
    COMPLETED = 'COMPLETED'
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call only works if 2FA is enabled on the account.
         * @summary Request a withdrawal
         * @param {CreateWithdrawalRequest} createWithdrawalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawal: async (createWithdrawalRequest: CreateWithdrawalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWithdrawalRequest' is not null or undefined
            if (createWithdrawalRequest === null || createWithdrawalRequest === undefined) {
                throw new RequiredError('createWithdrawalRequest','Required parameter createWithdrawalRequest was null or undefined when calling createWithdrawal.');
            }
            const localVarPath = `/withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createWithdrawalRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createWithdrawalRequest !== undefined ? createWithdrawalRequest : {}) : (createWithdrawalRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive current account balances
         * @param {string} account Account
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByTypeAndCurrency: async (account: string, currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account','Required parameter account was null or undefined when calling getAccountByTypeAndCurrency.');
            }
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling getAccountByTypeAndCurrency.');
            }
            const localVarPath = `/accounts/{account}/{currency}`
                .replace(`{${"account"}}`, encodeURIComponent(String(account)))
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive current account balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a deposit address. Currently only crypto currencies are supported
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling getDepositAddress.');
            }
            const localVarPath = `/deposits/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status about a deposit
         * @param {string} depositId Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositById: async (depositId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'depositId' is not null or undefined
            if (depositId === null || depositId === undefined) {
                throw new RequiredError('depositId','Required parameter depositId was null or undefined when calling getDepositById.');
            }
            const localVarPath = `/deposits/{depositId}`
                .replace(`{${"depositId"}}`, encodeURIComponent(String(depositId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of deposits
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeposits: async (from?: number, to?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/deposits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all whitelisted withdrawal accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhitelist: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/whitelist`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all whitelisted withdrawal accounts
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhitelistByCurrency: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling getWhitelistByCurrency.');
            }
            const localVarPath = `/whitelist/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status about a withdrawal
         * @param {string} withdrawalId Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalById: async (withdrawalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            if (withdrawalId === null || withdrawalId === undefined) {
                throw new RequiredError('withdrawalId','Required parameter withdrawalId was null or undefined when calling getWithdrawalById.');
            }
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of withdrawals
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals: async (from?: number, to?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdrawals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call only works if 2FA is enabled on the account.
         * @summary Request a withdrawal
         * @param {CreateWithdrawalRequest} createWithdrawalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalInfo>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).createWithdrawal(createWithdrawalRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Receive current account balances
         * @param {string} account Account
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByTypeAndCurrency(account: string, currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getAccountByTypeAndCurrency(account, currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Receive current account balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceMap>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getAccounts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a deposit address. Currently only crypto currencies are supported
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositAddress(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAddressCrypto>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getDepositAddress(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get status about a deposit
         * @param {string} depositId Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositById(depositId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositInfo>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getDepositById(depositId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of deposits
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeposits(from?: number, to?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DepositInfo>>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getDeposits(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all whitelisted withdrawal accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhitelist(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WhitelistEntry>>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getWhitelist(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all whitelisted withdrawal accounts
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhitelistByCurrency(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WhitelistEntry>>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getWhitelistByCurrency(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get status about a withdrawal
         * @param {string} withdrawalId Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalById(withdrawalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalInfo>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getWithdrawalById(withdrawalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of withdrawals
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawals(from?: number, to?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WithdrawalInfo>>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getWithdrawals(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This call only works if 2FA is enabled on the account.
         * @summary Request a withdrawal
         * @param {CreateWithdrawalRequest} createWithdrawalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, options?: any): AxiosPromise<WithdrawalInfo> {
            return PaymentsApiFp(configuration).createWithdrawal(createWithdrawalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive current account balances
         * @param {string} account Account
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByTypeAndCurrency(account: string, currency: string, options?: any): AxiosPromise<Balance> {
            return PaymentsApiFp(configuration).getAccountByTypeAndCurrency(account, currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive current account balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(options?: any): AxiosPromise<BalanceMap> {
            return PaymentsApiFp(configuration).getAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a deposit address. Currently only crypto currencies are supported
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositAddress(currency: string, options?: any): AxiosPromise<DepositAddressCrypto> {
            return PaymentsApiFp(configuration).getDepositAddress(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status about a deposit
         * @param {string} depositId Deposit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositById(depositId: string, options?: any): AxiosPromise<DepositInfo> {
            return PaymentsApiFp(configuration).getDepositById(depositId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of deposits
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeposits(from?: number, to?: number, options?: any): AxiosPromise<Array<DepositInfo>> {
            return PaymentsApiFp(configuration).getDeposits(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all whitelisted withdrawal accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhitelist(options?: any): AxiosPromise<Array<WhitelistEntry>> {
            return PaymentsApiFp(configuration).getWhitelist(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all whitelisted withdrawal accounts
         * @param {string} currency Currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhitelistByCurrency(currency: string, options?: any): AxiosPromise<Array<WhitelistEntry>> {
            return PaymentsApiFp(configuration).getWhitelistByCurrency(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status about a withdrawal
         * @param {string} withdrawalId Withdrawal ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalById(withdrawalId: string, options?: any): AxiosPromise<WithdrawalInfo> {
            return PaymentsApiFp(configuration).getWithdrawalById(withdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of withdrawals
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals(from?: number, to?: number, options?: any): AxiosPromise<Array<WithdrawalInfo>> {
            return PaymentsApiFp(configuration).getWithdrawals(from, to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * This call only works if 2FA is enabled on the account.
     * @summary Request a withdrawal
     * @param {CreateWithdrawalRequest} createWithdrawalRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createWithdrawal(createWithdrawalRequest: CreateWithdrawalRequest, options?: any) {
        return PaymentsApiFp(this.configuration).createWithdrawal(createWithdrawalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive current account balances
     * @param {string} account Account
     * @param {string} currency Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getAccountByTypeAndCurrency(account: string, currency: string, options?: any) {
        return PaymentsApiFp(this.configuration).getAccountByTypeAndCurrency(account, currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive current account balances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getAccounts(options?: any) {
        return PaymentsApiFp(this.configuration).getAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a deposit address. Currently only crypto currencies are supported
     * @param {string} currency Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getDepositAddress(currency: string, options?: any) {
        return PaymentsApiFp(this.configuration).getDepositAddress(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status about a deposit
     * @param {string} depositId Deposit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getDepositById(depositId: string, options?: any) {
        return PaymentsApiFp(this.configuration).getDepositById(depositId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of deposits
     * @param {number} [from] Epoch timestamp in ms
     * @param {number} [to] Epoch timestamp in ms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getDeposits(from?: number, to?: number, options?: any) {
        return PaymentsApiFp(this.configuration).getDeposits(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all whitelisted withdrawal accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getWhitelist(options?: any) {
        return PaymentsApiFp(this.configuration).getWhitelist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all whitelisted withdrawal accounts
     * @param {string} currency Currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getWhitelistByCurrency(currency: string, options?: any) {
        return PaymentsApiFp(this.configuration).getWhitelistByCurrency(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status about a withdrawal
     * @param {string} withdrawalId Withdrawal ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getWithdrawalById(withdrawalId: string, options?: any) {
        return PaymentsApiFp(this.configuration).getWithdrawalById(withdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of withdrawals
     * @param {number} [from] Epoch timestamp in ms
     * @param {number} [to] Epoch timestamp in ms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getWithdrawals(from?: number, to?: number, options?: any) {
        return PaymentsApiFp(this.configuration).getWithdrawals(from, to, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an order
         * @param {BaseOrder} baseOrder Trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (baseOrder: BaseOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseOrder' is not null or undefined
            if (baseOrder === null || baseOrder === undefined) {
                throw new RequiredError('baseOrder','Required parameter baseOrder was null or undefined when calling createOrder.');
            }
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof baseOrder !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(baseOrder !== undefined ? baseOrder : {}) : (baseOrder || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all open orders (of a symbol, if specified)
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOrders: async (symbol?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a trade
         * @param {number} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (orderId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling deleteOrder.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current fee level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fees`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific order
         * @param {number} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById: async (orderId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderById.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns live and historic orders, defaulting to live orders. Returns at most 50 results, use pagination to return further results
         * @summary Get a list orders
         * @param {string} [symbol] Only return results for this symbol
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {OrderStatus} [status] Order Status
         * @param {number} [page] Page number, starting at 0, for paginated responses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (symbol?: string, from?: number, to?: number, status?: OrderStatus, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an order
         * @param {BaseOrder} baseOrder Trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(baseOrder: BaseOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderSummary>> {
            const localVarAxiosArgs = await TradingApiAxiosParamCreator(configuration).createOrder(baseOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete all open orders (of a symbol, if specified)
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllOrders(symbol?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TradingApiAxiosParamCreator(configuration).deleteAllOrders(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancel a trade
         * @param {number} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(orderId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TradingApiAxiosParamCreator(configuration).deleteOrder(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get current fee level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFees(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fees>> {
            const localVarAxiosArgs = await TradingApiAxiosParamCreator(configuration).getFees(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a specific order
         * @param {number} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderById(orderId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderSummary>> {
            const localVarAxiosArgs = await TradingApiAxiosParamCreator(configuration).getOrderById(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns live and historic orders, defaulting to live orders. Returns at most 50 results, use pagination to return further results
         * @summary Get a list orders
         * @param {string} [symbol] Only return results for this symbol
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {OrderStatus} [status] Order Status
         * @param {number} [page] Page number, starting at 0, for paginated responses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(symbol?: string, from?: number, to?: number, status?: OrderStatus, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderSummary>>> {
            const localVarAxiosArgs = await TradingApiAxiosParamCreator(configuration).getOrders(symbol, from, to, status, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add an order
         * @param {BaseOrder} baseOrder Trade
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(baseOrder: BaseOrder, options?: any): AxiosPromise<OrderSummary> {
            return TradingApiFp(configuration).createOrder(baseOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all open orders (of a symbol, if specified)
         * @param {string} [symbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllOrders(symbol?: string, options?: any): AxiosPromise<void> {
            return TradingApiFp(configuration).deleteAllOrders(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a trade
         * @param {number} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: number, options?: any): AxiosPromise<void> {
            return TradingApiFp(configuration).deleteOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current fee level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees(options?: any): AxiosPromise<Fees> {
            return TradingApiFp(configuration).getFees(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific order
         * @param {number} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId: number, options?: any): AxiosPromise<OrderSummary> {
            return TradingApiFp(configuration).getOrderById(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns live and historic orders, defaulting to live orders. Returns at most 50 results, use pagination to return further results
         * @summary Get a list orders
         * @param {string} [symbol] Only return results for this symbol
         * @param {number} [from] Epoch timestamp in ms
         * @param {number} [to] Epoch timestamp in ms
         * @param {OrderStatus} [status] Order Status
         * @param {number} [page] Page number, starting at 0, for paginated responses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(symbol?: string, from?: number, to?: number, status?: OrderStatus, page?: number, options?: any): AxiosPromise<Array<OrderSummary>> {
            return TradingApiFp(configuration).getOrders(symbol, from, to, status, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
    /**
     * 
     * @summary Add an order
     * @param {BaseOrder} baseOrder Trade
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public createOrder(baseOrder: BaseOrder, options?: any) {
        return TradingApiFp(this.configuration).createOrder(baseOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all open orders (of a symbol, if specified)
     * @param {string} [symbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public deleteAllOrders(symbol?: string, options?: any) {
        return TradingApiFp(this.configuration).deleteAllOrders(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a trade
     * @param {number} orderId Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public deleteOrder(orderId: number, options?: any) {
        return TradingApiFp(this.configuration).deleteOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current fee level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getFees(options?: any) {
        return TradingApiFp(this.configuration).getFees(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific order
     * @param {number} orderId Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getOrderById(orderId: number, options?: any) {
        return TradingApiFp(this.configuration).getOrderById(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns live and historic orders, defaulting to live orders. Returns at most 50 results, use pagination to return further results
     * @summary Get a list orders
     * @param {string} [symbol] Only return results for this symbol
     * @param {number} [from] Epoch timestamp in ms
     * @param {number} [to] Epoch timestamp in ms
     * @param {OrderStatus} [status] Order Status
     * @param {number} [page] Page number, starting at 0, for paginated responses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getOrders(symbol?: string, from?: number, to?: number, status?: OrderStatus, page?: number, options?: any) {
        return TradingApiFp(this.configuration).getOrders(symbol, from, to, status, page, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UnauthenticatedApi - axios parameter creator
 * @export
 */
export const UnauthenticatedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Level 2 Order Book data is available through the l2 channel. This channel returns the volume available at each price. All the price levels are retrieved with this channel. Each entry in bids and asks arrays is a price level, along with its price (px), quantity (qty) and number of orders (num) attributes.
         * @summary L2 Order Book
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getL2OrderBook: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getL2OrderBook.');
            }
            const localVarPath = `/l2/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Level 3 Order Book data is available through the l3 channel. This channel returns all the order updates reaching the exchange; by applying the updates to the snapshot you can recreate the full state of the orderbook. Each entry in bids and asks arrays is an order, along with its id (id), price (px) and quantity (qty) attributes.
         * @summary L3 Order Book
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getL3OrderBook: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getL3OrderBook.');
            }
            const localVarPath = `/l3/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
         * @summary Symbols
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolByName: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getSymbolByName.');
            }
            const localVarPath = `/symbols/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
         * @summary Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbols: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/symbols`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Price
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBySymbol: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            if (symbol === null || symbol === undefined) {
                throw new RequiredError('symbol','Required parameter symbol was null or undefined when calling getTickerBySymbol.');
            }
            const localVarPath = `/tickers/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-API-Token")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-API-Token"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnauthenticatedApi - functional programming interface
 * @export
 */
export const UnauthenticatedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Level 2 Order Book data is available through the l2 channel. This channel returns the volume available at each price. All the price levels are retrieved with this channel. Each entry in bids and asks arrays is a price level, along with its price (px), quantity (qty) and number of orders (num) attributes.
         * @summary L2 Order Book
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getL2OrderBook(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderBook>> {
            const localVarAxiosArgs = await UnauthenticatedApiAxiosParamCreator(configuration).getL2OrderBook(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Level 3 Order Book data is available through the l3 channel. This channel returns all the order updates reaching the exchange; by applying the updates to the snapshot you can recreate the full state of the orderbook. Each entry in bids and asks arrays is an order, along with its id (id), price (px) and quantity (qty) attributes.
         * @summary L3 Order Book
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getL3OrderBook(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderBook>> {
            const localVarAxiosArgs = await UnauthenticatedApiAxiosParamCreator(configuration).getL3OrderBook(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
         * @summary Symbols
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbolByName(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SymbolStatus>> {
            const localVarAxiosArgs = await UnauthenticatedApiAxiosParamCreator(configuration).getSymbolByName(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
         * @summary Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbols(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: SymbolStatus; }>> {
            const localVarAxiosArgs = await UnauthenticatedApiAxiosParamCreator(configuration).getSymbols(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Price
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickerBySymbol(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceEvent>> {
            const localVarAxiosArgs = await UnauthenticatedApiAxiosParamCreator(configuration).getTickerBySymbol(symbol, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PriceEvent>>> {
            const localVarAxiosArgs = await UnauthenticatedApiAxiosParamCreator(configuration).getTickers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UnauthenticatedApi - factory interface
 * @export
 */
export const UnauthenticatedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Level 2 Order Book data is available through the l2 channel. This channel returns the volume available at each price. All the price levels are retrieved with this channel. Each entry in bids and asks arrays is a price level, along with its price (px), quantity (qty) and number of orders (num) attributes.
         * @summary L2 Order Book
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getL2OrderBook(symbol: string, options?: any): AxiosPromise<OrderBook> {
            return UnauthenticatedApiFp(configuration).getL2OrderBook(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Level 3 Order Book data is available through the l3 channel. This channel returns all the order updates reaching the exchange; by applying the updates to the snapshot you can recreate the full state of the orderbook. Each entry in bids and asks arrays is an order, along with its id (id), price (px) and quantity (qty) attributes.
         * @summary L3 Order Book
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getL3OrderBook(symbol: string, options?: any): AxiosPromise<OrderBook> {
            return UnauthenticatedApiFp(configuration).getL3OrderBook(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
         * @summary Symbols
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolByName(symbol: string, options?: any): AxiosPromise<SymbolStatus> {
            return UnauthenticatedApiFp(configuration).getSymbolByName(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
         * @summary Symbols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbols(options?: any): AxiosPromise<{ [key: string]: SymbolStatus; }> {
            return UnauthenticatedApiFp(configuration).getSymbols(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Price
         * @param {string} symbol Symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickerBySymbol(symbol: string, options?: any): AxiosPromise<PriceEvent> {
            return UnauthenticatedApiFp(configuration).getTickerBySymbol(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickers(options?: any): AxiosPromise<Array<PriceEvent>> {
            return UnauthenticatedApiFp(configuration).getTickers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnauthenticatedApi - object-oriented interface
 * @export
 * @class UnauthenticatedApi
 * @extends {BaseAPI}
 */
export class UnauthenticatedApi extends BaseAPI {
    /**
     * Level 2 Order Book data is available through the l2 channel. This channel returns the volume available at each price. All the price levels are retrieved with this channel. Each entry in bids and asks arrays is a price level, along with its price (px), quantity (qty) and number of orders (num) attributes.
     * @summary L2 Order Book
     * @param {string} symbol Symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnauthenticatedApi
     */
    public getL2OrderBook(symbol: string, options?: any) {
        return UnauthenticatedApiFp(this.configuration).getL2OrderBook(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Level 3 Order Book data is available through the l3 channel. This channel returns all the order updates reaching the exchange; by applying the updates to the snapshot you can recreate the full state of the orderbook. Each entry in bids and asks arrays is an order, along with its id (id), price (px) and quantity (qty) attributes.
     * @summary L3 Order Book
     * @param {string} symbol Symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnauthenticatedApi
     */
    public getL3OrderBook(symbol: string, options?: any) {
        return UnauthenticatedApiFp(this.configuration).getL3OrderBook(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
     * @summary Symbols
     * @param {string} symbol Symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnauthenticatedApi
     */
    public getSymbolByName(symbol: string, options?: any) {
        return UnauthenticatedApiFp(this.configuration).getSymbolByName(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
     * @summary Symbols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnauthenticatedApi
     */
    public getSymbols(options?: any) {
        return UnauthenticatedApiFp(this.configuration).getSymbols(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Price
     * @param {string} symbol Symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnauthenticatedApi
     */
    public getTickerBySymbol(symbol: string, options?: any) {
        return UnauthenticatedApiFp(this.configuration).getTickerBySymbol(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnauthenticatedApi
     */
    public getTickers(options?: any) {
        return UnauthenticatedApiFp(this.configuration).getTickers(options).then((request) => request(this.axios, this.basePath));
    }

}



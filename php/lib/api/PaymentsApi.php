<?php
/**
 * PaymentsApi
 * PHP version 5
 *
 * @category Class
 * @package  com.blockchain.exchange.rest
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Blockchain.com Exchange REST API
 *
 * ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. \\ These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account \\ Select API from the drop down menu \\ Fill out form and click “Create New API Key Now” \\ Once generated you can view your keys under API Settings. \\ Please be aware that the API key can only be used once it was verified via email.  The API key must be set via the \\ `X-API-Token`\\ header.  The base URL to be used for all calls is \\ `https://api.blockchain.com/v3/exchange`  Autogenerated clients for this API can be found [here](https://github.com/blockchain/lib-exchange-client).
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.blockchain.exchange.rest\com.blockchain.exchange.rest.api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.blockchain.exchange.rest\ApiException;
use com.blockchain.exchange.rest\Configuration;
use com.blockchain.exchange.rest\HeaderSelector;
use com.blockchain.exchange.rest\ObjectSerializer;

/**
 * PaymentsApi Class Doc Comment
 *
 * @category Class
 * @package  com.blockchain.exchange.rest
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PaymentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createWithdrawal
     *
     * Request a withdrawal
     *
     * @param  \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\CreateWithdrawalRequest $create_withdrawal_request create_withdrawal_request (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo
     */
    public function createWithdrawal($create_withdrawal_request)
    {
        list($response) = $this->createWithdrawalWithHttpInfo($create_withdrawal_request);
        return $response;
    }

    /**
     * Operation createWithdrawalWithHttpInfo
     *
     * Request a withdrawal
     *
     * @param  \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\CreateWithdrawalRequest $create_withdrawal_request (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithdrawalWithHttpInfo($create_withdrawal_request)
    {
        $request = $this->createWithdrawalRequest($create_withdrawal_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createWithdrawalAsync
     *
     * Request a withdrawal
     *
     * @param  \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\CreateWithdrawalRequest $create_withdrawal_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithdrawalAsync($create_withdrawal_request)
    {
        return $this->createWithdrawalAsyncWithHttpInfo($create_withdrawal_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWithdrawalAsyncWithHttpInfo
     *
     * Request a withdrawal
     *
     * @param  \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\CreateWithdrawalRequest $create_withdrawal_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithdrawalAsyncWithHttpInfo($create_withdrawal_request)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo';
        $request = $this->createWithdrawalRequest($create_withdrawal_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWithdrawal'
     *
     * @param  \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\CreateWithdrawalRequest $create_withdrawal_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createWithdrawalRequest($create_withdrawal_request)
    {
        // verify the required parameter 'create_withdrawal_request' is set
        if ($create_withdrawal_request === null || (is_array($create_withdrawal_request) && count($create_withdrawal_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_withdrawal_request when calling createWithdrawal'
            );
        }

        $resourcePath = '/withdrawals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($create_withdrawal_request)) {
            $_tempBody = $create_withdrawal_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountByTypeAndCurrency
     *
     * Receive current account balances
     *
     * @param  string $account Account (required)
     * @param  string $currency Currency (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance
     */
    public function getAccountByTypeAndCurrency($account, $currency)
    {
        list($response) = $this->getAccountByTypeAndCurrencyWithHttpInfo($account, $currency);
        return $response;
    }

    /**
     * Operation getAccountByTypeAndCurrencyWithHttpInfo
     *
     * Receive current account balances
     *
     * @param  string $account Account (required)
     * @param  string $currency Currency (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountByTypeAndCurrencyWithHttpInfo($account, $currency)
    {
        $request = $this->getAccountByTypeAndCurrencyRequest($account, $currency);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountByTypeAndCurrencyAsync
     *
     * Receive current account balances
     *
     * @param  string $account Account (required)
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountByTypeAndCurrencyAsync($account, $currency)
    {
        return $this->getAccountByTypeAndCurrencyAsyncWithHttpInfo($account, $currency)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountByTypeAndCurrencyAsyncWithHttpInfo
     *
     * Receive current account balances
     *
     * @param  string $account Account (required)
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountByTypeAndCurrencyAsyncWithHttpInfo($account, $currency)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\Balance';
        $request = $this->getAccountByTypeAndCurrencyRequest($account, $currency);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountByTypeAndCurrency'
     *
     * @param  string $account Account (required)
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountByTypeAndCurrencyRequest($account, $currency)
    {
        // verify the required parameter 'account' is set
        if ($account === null || (is_array($account) && count($account) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account when calling getAccountByTypeAndCurrency'
            );
        }
        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getAccountByTypeAndCurrency'
            );
        }
        if (!preg_match("/^[A-Z]{3,5}$/", $currency)) {
            throw new \InvalidArgumentException("invalid value for \"currency\" when calling PaymentsApi.getAccountByTypeAndCurrency, must conform to the pattern /^[A-Z]{3,5}$/.");
        }


        $resourcePath = '/accounts/{account}/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($account !== null) {
            $resourcePath = str_replace(
                '{' . 'account' . '}',
                ObjectSerializer::toPathValue($account),
                $resourcePath
            );
        }
        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccounts
     *
     * Receive current account balances
     *
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap
     */
    public function getAccounts()
    {
        list($response) = $this->getAccountsWithHttpInfo();
        return $response;
    }

    /**
     * Operation getAccountsWithHttpInfo
     *
     * Receive current account balances
     *
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountsWithHttpInfo()
    {
        $request = $this->getAccountsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountsAsync
     *
     * Receive current account balances
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountsAsync()
    {
        return $this->getAccountsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountsAsyncWithHttpInfo
     *
     * Receive current account balances
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountsAsyncWithHttpInfo()
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\BalanceMap';
        $request = $this->getAccountsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccounts'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccountsRequest()
    {

        $resourcePath = '/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDepositAddress
     *
     * Get a deposit address. Currently only crypto currencies are supported
     *
     * @param  string $currency Currency (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto
     */
    public function getDepositAddress($currency)
    {
        list($response) = $this->getDepositAddressWithHttpInfo($currency);
        return $response;
    }

    /**
     * Operation getDepositAddressWithHttpInfo
     *
     * Get a deposit address. Currently only crypto currencies are supported
     *
     * @param  string $currency Currency (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDepositAddressWithHttpInfo($currency)
    {
        $request = $this->getDepositAddressRequest($currency);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDepositAddressAsync
     *
     * Get a deposit address. Currently only crypto currencies are supported
     *
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositAddressAsync($currency)
    {
        return $this->getDepositAddressAsyncWithHttpInfo($currency)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDepositAddressAsyncWithHttpInfo
     *
     * Get a deposit address. Currently only crypto currencies are supported
     *
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositAddressAsyncWithHttpInfo($currency)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositAddressCrypto';
        $request = $this->getDepositAddressRequest($currency);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDepositAddress'
     *
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDepositAddressRequest($currency)
    {
        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getDepositAddress'
            );
        }
        if (!preg_match("/^[A-Z]{3,5}$/", $currency)) {
            throw new \InvalidArgumentException("invalid value for \"currency\" when calling PaymentsApi.getDepositAddress, must conform to the pattern /^[A-Z]{3,5}$/.");
        }


        $resourcePath = '/deposits/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDepositById
     *
     * Get status about a deposit
     *
     * @param  string $deposit_id Deposit ID (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo
     */
    public function getDepositById($deposit_id)
    {
        list($response) = $this->getDepositByIdWithHttpInfo($deposit_id);
        return $response;
    }

    /**
     * Operation getDepositByIdWithHttpInfo
     *
     * Get status about a deposit
     *
     * @param  string $deposit_id Deposit ID (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDepositByIdWithHttpInfo($deposit_id)
    {
        $request = $this->getDepositByIdRequest($deposit_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDepositByIdAsync
     *
     * Get status about a deposit
     *
     * @param  string $deposit_id Deposit ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositByIdAsync($deposit_id)
    {
        return $this->getDepositByIdAsyncWithHttpInfo($deposit_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDepositByIdAsyncWithHttpInfo
     *
     * Get status about a deposit
     *
     * @param  string $deposit_id Deposit ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositByIdAsyncWithHttpInfo($deposit_id)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo';
        $request = $this->getDepositByIdRequest($deposit_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDepositById'
     *
     * @param  string $deposit_id Deposit ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDepositByIdRequest($deposit_id)
    {
        // verify the required parameter 'deposit_id' is set
        if ($deposit_id === null || (is_array($deposit_id) && count($deposit_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deposit_id when calling getDepositById'
            );
        }

        $resourcePath = '/deposits/{depositId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($deposit_id !== null) {
            $resourcePath = str_replace(
                '{' . 'depositId' . '}',
                ObjectSerializer::toPathValue($deposit_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeposits
     *
     * Get a list of deposits
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[]
     */
    public function getDeposits($from = null, $to = null)
    {
        list($response) = $this->getDepositsWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation getDepositsWithHttpInfo
     *
     * Get a list of deposits
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getDepositsWithHttpInfo($from = null, $to = null)
    {
        $request = $this->getDepositsRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDepositsAsync
     *
     * Get a list of deposits
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositsAsync($from = null, $to = null)
    {
        return $this->getDepositsAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDepositsAsyncWithHttpInfo
     *
     * Get a list of deposits
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDepositsAsyncWithHttpInfo($from = null, $to = null)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\DepositInfo[]';
        $request = $this->getDepositsRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeposits'
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDepositsRequest($from = null, $to = null)
    {

        $resourcePath = '/deposits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWhitelist
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]
     */
    public function getWhitelist()
    {
        list($response) = $this->getWhitelistWithHttpInfo();
        return $response;
    }

    /**
     * Operation getWhitelistWithHttpInfo
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getWhitelistWithHttpInfo()
    {
        $request = $this->getWhitelistRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWhitelistAsync
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWhitelistAsync()
    {
        return $this->getWhitelistAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWhitelistAsyncWithHttpInfo
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWhitelistAsyncWithHttpInfo()
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]';
        $request = $this->getWhitelistRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWhitelist'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWhitelistRequest()
    {

        $resourcePath = '/whitelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWhitelistByCurrency
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     * @param  string $currency Currency (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]
     */
    public function getWhitelistByCurrency($currency)
    {
        list($response) = $this->getWhitelistByCurrencyWithHttpInfo($currency);
        return $response;
    }

    /**
     * Operation getWhitelistByCurrencyWithHttpInfo
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     * @param  string $currency Currency (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getWhitelistByCurrencyWithHttpInfo($currency)
    {
        $request = $this->getWhitelistByCurrencyRequest($currency);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWhitelistByCurrencyAsync
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWhitelistByCurrencyAsync($currency)
    {
        return $this->getWhitelistByCurrencyAsyncWithHttpInfo($currency)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWhitelistByCurrencyAsyncWithHttpInfo
     *
     * Get a list of all whitelisted withdrawal accounts
     *
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWhitelistByCurrencyAsyncWithHttpInfo($currency)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WhitelistEntry[]';
        $request = $this->getWhitelistByCurrencyRequest($currency);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWhitelistByCurrency'
     *
     * @param  string $currency Currency (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWhitelistByCurrencyRequest($currency)
    {
        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getWhitelistByCurrency'
            );
        }
        if (!preg_match("/^[A-Z]{3,5}$/", $currency)) {
            throw new \InvalidArgumentException("invalid value for \"currency\" when calling PaymentsApi.getWhitelistByCurrency, must conform to the pattern /^[A-Z]{3,5}$/.");
        }


        $resourcePath = '/whitelist/{currency}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency !== null) {
            $resourcePath = str_replace(
                '{' . 'currency' . '}',
                ObjectSerializer::toPathValue($currency),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWithdrawalById
     *
     * Get status about a withdrawal
     *
     * @param  string $withdrawal_id Withdrawal ID (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo
     */
    public function getWithdrawalById($withdrawal_id)
    {
        list($response) = $this->getWithdrawalByIdWithHttpInfo($withdrawal_id);
        return $response;
    }

    /**
     * Operation getWithdrawalByIdWithHttpInfo
     *
     * Get status about a withdrawal
     *
     * @param  string $withdrawal_id Withdrawal ID (required)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithdrawalByIdWithHttpInfo($withdrawal_id)
    {
        $request = $this->getWithdrawalByIdRequest($withdrawal_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWithdrawalByIdAsync
     *
     * Get status about a withdrawal
     *
     * @param  string $withdrawal_id Withdrawal ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalByIdAsync($withdrawal_id)
    {
        return $this->getWithdrawalByIdAsyncWithHttpInfo($withdrawal_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWithdrawalByIdAsyncWithHttpInfo
     *
     * Get status about a withdrawal
     *
     * @param  string $withdrawal_id Withdrawal ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalByIdAsyncWithHttpInfo($withdrawal_id)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo';
        $request = $this->getWithdrawalByIdRequest($withdrawal_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWithdrawalById'
     *
     * @param  string $withdrawal_id Withdrawal ID (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWithdrawalByIdRequest($withdrawal_id)
    {
        // verify the required parameter 'withdrawal_id' is set
        if ($withdrawal_id === null || (is_array($withdrawal_id) && count($withdrawal_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $withdrawal_id when calling getWithdrawalById'
            );
        }

        $resourcePath = '/withdrawals/{withdrawalId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($withdrawal_id !== null) {
            $resourcePath = str_replace(
                '{' . 'withdrawalId' . '}',
                ObjectSerializer::toPathValue($withdrawal_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWithdrawals
     *
     * Get a list of withdrawals
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[]
     */
    public function getWithdrawals($from = null, $to = null)
    {
        list($response) = $this->getWithdrawalsWithHttpInfo($from, $to);
        return $response;
    }

    /**
     * Operation getWithdrawalsWithHttpInfo
     *
     * Get a list of withdrawals
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \com.blockchain.exchange.rest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithdrawalsWithHttpInfo($from = null, $to = null)
    {
        $request = $this->getWithdrawalsRequest($from, $to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWithdrawalsAsync
     *
     * Get a list of withdrawals
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalsAsync($from = null, $to = null)
    {
        return $this->getWithdrawalsAsyncWithHttpInfo($from, $to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWithdrawalsAsyncWithHttpInfo
     *
     * Get a list of withdrawals
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalsAsyncWithHttpInfo($from = null, $to = null)
    {
        $returnType = '\com.blockchain.exchange.rest\com.blockchain.exchange.rest.model\WithdrawalInfo[]';
        $request = $this->getWithdrawalsRequest($from, $to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWithdrawals'
     *
     * @param  int $from Epoch timestamp in ms (optional)
     * @param  int $to Epoch timestamp in ms (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWithdrawalsRequest($from = null, $to = null)
    {

        $resourcePath = '/withdrawals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

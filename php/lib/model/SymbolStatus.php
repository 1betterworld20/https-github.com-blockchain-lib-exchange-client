<?php
/**
 * SymbolStatus
 *
 * PHP version 5
 *
 * @category Class
 * @package  com.blockchain.exchange.rest
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Blockchain.com Exchange REST API
 *
 * ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account Select API from the drop down menu Fill out form and click “Create New API Key Now” Once generated you can view your keys under API Settings
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.blockchain.exchange.rest\com.blockchain.exchange.rest.model;

use \ArrayAccess;
use \com.blockchain.exchange.rest\ObjectSerializer;

/**
 * SymbolStatus Class Doc Comment
 *
 * @category Class
 * @package  com.blockchain.exchange.rest
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SymbolStatus implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SymbolStatus';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'base_currency' => 'string',
        'base_currency_scale' => 'int',
        'counter_currency' => 'string',
        'counter_currency_scale' => 'int',
        'min_price_increment' => 'int',
        'min_price_increment_scale' => 'int',
        'min_order_size' => 'int',
        'min_order_size_scale' => 'int',
        'max_order_size' => 'int',
        'max_order_size_scale' => 'int',
        'lot_size' => 'int',
        'lot_size_scale' => 'int',
        'status' => 'string',
        'id' => 'int',
        'auction_price' => 'double',
        'auction_size' => 'double',
        'auction_time' => 'int',
        'imbalance' => 'double'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'base_currency' => null,
        'base_currency_scale' => null,
        'counter_currency' => null,
        'counter_currency_scale' => null,
        'min_price_increment' => 'int64',
        'min_price_increment_scale' => null,
        'min_order_size' => 'int64',
        'min_order_size_scale' => null,
        'max_order_size' => 'int64',
        'max_order_size_scale' => null,
        'lot_size' => 'int64',
        'lot_size_scale' => null,
        'status' => null,
        'id' => 'int64',
        'auction_price' => 'double',
        'auction_size' => 'double',
        'auction_time' => null,
        'imbalance' => 'double'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'base_currency' => 'base_currency',
        'base_currency_scale' => 'base_currency_scale',
        'counter_currency' => 'counter_currency',
        'counter_currency_scale' => 'counter_currency_scale',
        'min_price_increment' => 'min_price_increment',
        'min_price_increment_scale' => 'min_price_increment_scale',
        'min_order_size' => 'min_order_size',
        'min_order_size_scale' => 'min_order_size_scale',
        'max_order_size' => 'max_order_size',
        'max_order_size_scale' => 'max_order_size_scale',
        'lot_size' => 'lot_size',
        'lot_size_scale' => 'lot_size_scale',
        'status' => 'status',
        'id' => 'id',
        'auction_price' => 'auction_price',
        'auction_size' => 'auction_size',
        'auction_time' => 'auction_time',
        'imbalance' => 'imbalance'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'base_currency' => 'setBaseCurrency',
        'base_currency_scale' => 'setBaseCurrencyScale',
        'counter_currency' => 'setCounterCurrency',
        'counter_currency_scale' => 'setCounterCurrencyScale',
        'min_price_increment' => 'setMinPriceIncrement',
        'min_price_increment_scale' => 'setMinPriceIncrementScale',
        'min_order_size' => 'setMinOrderSize',
        'min_order_size_scale' => 'setMinOrderSizeScale',
        'max_order_size' => 'setMaxOrderSize',
        'max_order_size_scale' => 'setMaxOrderSizeScale',
        'lot_size' => 'setLotSize',
        'lot_size_scale' => 'setLotSizeScale',
        'status' => 'setStatus',
        'id' => 'setId',
        'auction_price' => 'setAuctionPrice',
        'auction_size' => 'setAuctionSize',
        'auction_time' => 'setAuctionTime',
        'imbalance' => 'setImbalance'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'base_currency' => 'getBaseCurrency',
        'base_currency_scale' => 'getBaseCurrencyScale',
        'counter_currency' => 'getCounterCurrency',
        'counter_currency_scale' => 'getCounterCurrencyScale',
        'min_price_increment' => 'getMinPriceIncrement',
        'min_price_increment_scale' => 'getMinPriceIncrementScale',
        'min_order_size' => 'getMinOrderSize',
        'min_order_size_scale' => 'getMinOrderSizeScale',
        'max_order_size' => 'getMaxOrderSize',
        'max_order_size_scale' => 'getMaxOrderSizeScale',
        'lot_size' => 'getLotSize',
        'lot_size_scale' => 'getLotSizeScale',
        'status' => 'getStatus',
        'id' => 'getId',
        'auction_price' => 'getAuctionPrice',
        'auction_size' => 'getAuctionSize',
        'auction_time' => 'getAuctionTime',
        'imbalance' => 'getImbalance'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const STATUS_OPEN = 'open';
    const STATUS_CLOSE = 'close';
    const STATUS_SUSPEND = 'suspend';
    const STATUS_HALT = 'halt';
    const STATUS_HALT_FREEZE = 'halt-freeze';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_OPEN,
            self::STATUS_CLOSE,
            self::STATUS_SUSPEND,
            self::STATUS_HALT,
            self::STATUS_HALT_FREEZE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['base_currency'] = isset($data['base_currency']) ? $data['base_currency'] : null;
        $this->container['base_currency_scale'] = isset($data['base_currency_scale']) ? $data['base_currency_scale'] : null;
        $this->container['counter_currency'] = isset($data['counter_currency']) ? $data['counter_currency'] : null;
        $this->container['counter_currency_scale'] = isset($data['counter_currency_scale']) ? $data['counter_currency_scale'] : null;
        $this->container['min_price_increment'] = isset($data['min_price_increment']) ? $data['min_price_increment'] : null;
        $this->container['min_price_increment_scale'] = isset($data['min_price_increment_scale']) ? $data['min_price_increment_scale'] : null;
        $this->container['min_order_size'] = isset($data['min_order_size']) ? $data['min_order_size'] : null;
        $this->container['min_order_size_scale'] = isset($data['min_order_size_scale']) ? $data['min_order_size_scale'] : null;
        $this->container['max_order_size'] = isset($data['max_order_size']) ? $data['max_order_size'] : null;
        $this->container['max_order_size_scale'] = isset($data['max_order_size_scale']) ? $data['max_order_size_scale'] : null;
        $this->container['lot_size'] = isset($data['lot_size']) ? $data['lot_size'] : null;
        $this->container['lot_size_scale'] = isset($data['lot_size_scale']) ? $data['lot_size_scale'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['auction_price'] = isset($data['auction_price']) ? $data['auction_price'] : null;
        $this->container['auction_size'] = isset($data['auction_size']) ? $data['auction_size'] : null;
        $this->container['auction_time'] = isset($data['auction_time']) ? $data['auction_time'] : null;
        $this->container['imbalance'] = isset($data['imbalance']) ? $data['imbalance'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['base_currency']) && !preg_match("/^[A-Z]{3,5}-[A-Z]{3,5}$/", $this->container['base_currency'])) {
            $invalidProperties[] = "invalid value for 'base_currency', must be conform to the pattern /^[A-Z]{3,5}-[A-Z]{3,5}$/.";
        }

        if (!is_null($this->container['counter_currency']) && !preg_match("/^[A-Z]{3,5}-[A-Z]{3,5}$/", $this->container['counter_currency'])) {
            $invalidProperties[] = "invalid value for 'counter_currency', must be conform to the pattern /^[A-Z]{3,5}-[A-Z]{3,5}$/.";
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets base_currency
     *
     * @return string|null
     */
    public function getBaseCurrency()
    {
        return $this->container['base_currency'];
    }

    /**
     * Sets base_currency
     *
     * @param string|null $base_currency Blockchain symbol identifier
     *
     * @return $this
     */
    public function setBaseCurrency($base_currency)
    {

        if (!is_null($base_currency) && (!preg_match("/^[A-Z]{3,5}-[A-Z]{3,5}$/", $base_currency))) {
            throw new \InvalidArgumentException("invalid value for $base_currency when calling SymbolStatus., must conform to the pattern /^[A-Z]{3,5}-[A-Z]{3,5}$/.");
        }

        $this->container['base_currency'] = $base_currency;

        return $this;
    }

    /**
     * Gets base_currency_scale
     *
     * @return int|null
     */
    public function getBaseCurrencyScale()
    {
        return $this->container['base_currency_scale'];
    }

    /**
     * Sets base_currency_scale
     *
     * @param int|null $base_currency_scale The number of decimals the currency can be split in
     *
     * @return $this
     */
    public function setBaseCurrencyScale($base_currency_scale)
    {
        $this->container['base_currency_scale'] = $base_currency_scale;

        return $this;
    }

    /**
     * Gets counter_currency
     *
     * @return string|null
     */
    public function getCounterCurrency()
    {
        return $this->container['counter_currency'];
    }

    /**
     * Sets counter_currency
     *
     * @param string|null $counter_currency Blockchain symbol identifier
     *
     * @return $this
     */
    public function setCounterCurrency($counter_currency)
    {

        if (!is_null($counter_currency) && (!preg_match("/^[A-Z]{3,5}-[A-Z]{3,5}$/", $counter_currency))) {
            throw new \InvalidArgumentException("invalid value for $counter_currency when calling SymbolStatus., must conform to the pattern /^[A-Z]{3,5}-[A-Z]{3,5}$/.");
        }

        $this->container['counter_currency'] = $counter_currency;

        return $this;
    }

    /**
     * Gets counter_currency_scale
     *
     * @return int|null
     */
    public function getCounterCurrencyScale()
    {
        return $this->container['counter_currency_scale'];
    }

    /**
     * Sets counter_currency_scale
     *
     * @param int|null $counter_currency_scale The number of decimals the currency can be split in
     *
     * @return $this
     */
    public function setCounterCurrencyScale($counter_currency_scale)
    {
        $this->container['counter_currency_scale'] = $counter_currency_scale;

        return $this;
    }

    /**
     * Gets min_price_increment
     *
     * @return int|null
     */
    public function getMinPriceIncrement()
    {
        return $this->container['min_price_increment'];
    }

    /**
     * Sets min_price_increment
     *
     * @param int|null $min_price_increment The price of the instrument must be a multiple of min_price_increment * (10^-min_price_increment_scale)
     *
     * @return $this
     */
    public function setMinPriceIncrement($min_price_increment)
    {
        $this->container['min_price_increment'] = $min_price_increment;

        return $this;
    }

    /**
     * Gets min_price_increment_scale
     *
     * @return int|null
     */
    public function getMinPriceIncrementScale()
    {
        return $this->container['min_price_increment_scale'];
    }

    /**
     * Sets min_price_increment_scale
     *
     * @param int|null $min_price_increment_scale min_price_increment_scale
     *
     * @return $this
     */
    public function setMinPriceIncrementScale($min_price_increment_scale)
    {
        $this->container['min_price_increment_scale'] = $min_price_increment_scale;

        return $this;
    }

    /**
     * Gets min_order_size
     *
     * @return int|null
     */
    public function getMinOrderSize()
    {
        return $this->container['min_order_size'];
    }

    /**
     * Sets min_order_size
     *
     * @param int|null $min_order_size The minimum quantity for an order for this instrument must be min_order_size*(10^-min_order_size_scale)
     *
     * @return $this
     */
    public function setMinOrderSize($min_order_size)
    {
        $this->container['min_order_size'] = $min_order_size;

        return $this;
    }

    /**
     * Gets min_order_size_scale
     *
     * @return int|null
     */
    public function getMinOrderSizeScale()
    {
        return $this->container['min_order_size_scale'];
    }

    /**
     * Sets min_order_size_scale
     *
     * @param int|null $min_order_size_scale min_order_size_scale
     *
     * @return $this
     */
    public function setMinOrderSizeScale($min_order_size_scale)
    {
        $this->container['min_order_size_scale'] = $min_order_size_scale;

        return $this;
    }

    /**
     * Gets max_order_size
     *
     * @return int|null
     */
    public function getMaxOrderSize()
    {
        return $this->container['max_order_size'];
    }

    /**
     * Sets max_order_size
     *
     * @param int|null $max_order_size The maximum quantity for an order for this instrument is max_order_size*(10^-max_order_size_scale). If this equal to zero, there is no limit
     *
     * @return $this
     */
    public function setMaxOrderSize($max_order_size)
    {
        $this->container['max_order_size'] = $max_order_size;

        return $this;
    }

    /**
     * Gets max_order_size_scale
     *
     * @return int|null
     */
    public function getMaxOrderSizeScale()
    {
        return $this->container['max_order_size_scale'];
    }

    /**
     * Sets max_order_size_scale
     *
     * @param int|null $max_order_size_scale max_order_size_scale
     *
     * @return $this
     */
    public function setMaxOrderSizeScale($max_order_size_scale)
    {
        $this->container['max_order_size_scale'] = $max_order_size_scale;

        return $this;
    }

    /**
     * Gets lot_size
     *
     * @return int|null
     */
    public function getLotSize()
    {
        return $this->container['lot_size'];
    }

    /**
     * Sets lot_size
     *
     * @param int|null $lot_size lot_size
     *
     * @return $this
     */
    public function setLotSize($lot_size)
    {
        $this->container['lot_size'] = $lot_size;

        return $this;
    }

    /**
     * Gets lot_size_scale
     *
     * @return int|null
     */
    public function getLotSizeScale()
    {
        return $this->container['lot_size_scale'];
    }

    /**
     * Sets lot_size_scale
     *
     * @param int|null $lot_size_scale lot_size_scale
     *
     * @return $this
     */
    public function setLotSizeScale($lot_size_scale)
    {
        $this->container['lot_size_scale'] = $lot_size_scale;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Symbol status; open, close, suspend, halt, halt-freeze.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id id
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets auction_price
     *
     * @return double|null
     */
    public function getAuctionPrice()
    {
        return $this->container['auction_price'];
    }

    /**
     * Sets auction_price
     *
     * @param double|null $auction_price If the symbol is halted and will open on an auction, this will be the opening price.
     *
     * @return $this
     */
    public function setAuctionPrice($auction_price)
    {
        $this->container['auction_price'] = $auction_price;

        return $this;
    }

    /**
     * Gets auction_size
     *
     * @return double|null
     */
    public function getAuctionSize()
    {
        return $this->container['auction_size'];
    }

    /**
     * Sets auction_size
     *
     * @param double|null $auction_size Opening size
     *
     * @return $this
     */
    public function setAuctionSize($auction_size)
    {
        $this->container['auction_size'] = $auction_size;

        return $this;
    }

    /**
     * Gets auction_time
     *
     * @return int|null
     */
    public function getAuctionTime()
    {
        return $this->container['auction_time'];
    }

    /**
     * Sets auction_time
     *
     * @param int|null $auction_time Opening time in HHMM format
     *
     * @return $this
     */
    public function setAuctionTime($auction_time)
    {
        $this->container['auction_time'] = $auction_time;

        return $this;
    }

    /**
     * Gets imbalance
     *
     * @return double|null
     */
    public function getImbalance()
    {
        return $this->container['imbalance'];
    }

    /**
     * Sets imbalance
     *
     * @param double|null $imbalance Auction imbalance. If > 0 then there will be buy orders left over at the auction price. If < 0 then there will be sell orders left over at the auction price.
     *
     * @return $this
     */
    public function setImbalance($imbalance)
    {
        $this->container['imbalance'] = $imbalance;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}



{-
   Blockchain.com Exchange REST API
   ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. \\ These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account \\ Select API from the drop down menu \\ Fill out form and click “Create New API Key Now” \\ Once generated you can view your keys under API Settings. \\ Please be aware that the API key can only be used once it was verified via email.  The API key must be set via the \\ `X-API-Token`\\ header.  The base URL to be used for all calls is \\ `https://api.blockchain.com/v3/exchange`  Autogenerated clients for this API can be found [here](https://github.com/blockchain/lib-exchange-client). 

   The version of the OpenAPI document: 1.0.0

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git
   Do not edit this file manually.
-}


module Request.Trading exposing (createOrder, deleteAllOrders, deleteOrder, getFees, getFills, getOrderById, getOrders)

import Data.OrderStatus as OrderStatus exposing (OrderStatus)
import Data.BaseOrder as BaseOrder exposing (BaseOrder)
import Data.OrderSummary as OrderSummary exposing (OrderSummary)
import Data.Fees as Fees exposing (Fees)
import Dict
import Http
import Json.Decode as Decode
import Url.Builder as Url




basePath : String
basePath =
    "https://api.blockchain.com/v3/exchange"


createOrder :
    { onSend : Result Http.Error OrderSummary -> msg


    , body : BaseOrder


    }
    -> Cmd msg
createOrder params =
    Http.request
        { method = "POST"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["orders"]
            (List.filterMap identity [])
        , body = Http.jsonBody <| BaseOrder.encode params.body
        , expect = Http.expectJson params.onSend OrderSummary.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


deleteAllOrders :
    { onSend : Result Http.Error () -> msg




    , symbol : Maybe (String)
    }
    -> Cmd msg
deleteAllOrders params =
    Http.request
        { method = "DELETE"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["orders"]
            (List.filterMap identity [Maybe.map (Url.string "symbol" << identity) params.symbol])
        , body = Http.emptyBody
        , expect = Http.expectWhatever params.onSend
        , timeout = Just 30000
        , tracker = Nothing
        }


deleteOrder :
    { onSend : Result Http.Error () -> msg



    , orderId : Int

    }
    -> Cmd msg
deleteOrder params =
    Http.request
        { method = "DELETE"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["orders", String.fromInt params.orderId]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectWhatever params.onSend
        , timeout = Just 30000
        , tracker = Nothing
        }


getFees :
    { onSend : Result Http.Error Fees -> msg





    }
    -> Cmd msg
getFees params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["fees"]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend Fees.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


{-| Returns filled orders, including partial fills. Returns at most 100 results, use timestamp to paginate for further results
-}
getFills :
    { onSend : Result Http.Error (List OrderSummary) -> msg




    , symbol : Maybe (String)    , from : Maybe (Int)    , to : Maybe (Int)    , limit : Maybe (Int)
    }
    -> Cmd msg
getFills params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["trades"]
            (List.filterMap identity [Maybe.map (Url.string "symbol" << identity) params.symbol, Maybe.map (Url.string "from" << String.fromInt) params.from, Maybe.map (Url.string "to" << String.fromInt) params.to, Maybe.map (Url.string "limit" << String.fromInt) params.limit])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend (Decode.list OrderSummary.decoder)
        , timeout = Just 30000
        , tracker = Nothing
        }


getOrderById :
    { onSend : Result Http.Error OrderSummary -> msg



    , orderId : Int

    }
    -> Cmd msg
getOrderById params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["orders", String.fromInt params.orderId]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend OrderSummary.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


{-| Returns live and historic orders, defaulting to live orders. Returns at most 100 results, use timestamp to paginate for further results
-}
getOrders :
    { onSend : Result Http.Error (List OrderSummary) -> msg




    , symbol : Maybe (String)    , from : Maybe (Int)    , to : Maybe (Int)    , status : Maybe (OrderStatus)    , limit : Maybe (Int)
    }
    -> Cmd msg
getOrders params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["orders"]
            (List.filterMap identity [Maybe.map (Url.string "symbol" << identity) params.symbol, Maybe.map (Url.string "from" << String.fromInt) params.from, Maybe.map (Url.string "to" << String.fromInt) params.to, Maybe.map (Url.string "status" << OrderStatus.toString) params.status, Maybe.map (Url.string "limit" << String.fromInt) params.limit])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend (Decode.list OrderSummary.decoder)
        , timeout = Just 30000
        , tracker = Nothing
        }

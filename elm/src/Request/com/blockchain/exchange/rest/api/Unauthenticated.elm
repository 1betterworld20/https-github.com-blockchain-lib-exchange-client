{-
   Blockchain.com Exchange REST API
   ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account Select API from the drop down menu Fill out form and click “Create New API Key Now” Once generated you can view your keys under API Settings 

   The version of the OpenAPI document: 1.0.0

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git
   Do not edit this file manually.
-}


module Request.Unauthenticated exposing (getL2OrderBook, getL3OrderBook, getSymbolByName, getSymbols, getTickerBySymbol, getTickers)

import Data.SymbolStatus as SymbolStatus exposing (SymbolStatus)
import Data.OrderBook as OrderBook exposing (OrderBook)
import Data.PriceEvent as PriceEvent exposing (PriceEvent)
import Dict
import Http
import Json.Decode as Decode
import Url.Builder as Url




basePath : String
basePath =
    "https://api.blockchain.com/v3/exchange"


{-| Level 2 Order Book data is available through the l2 channel. This channel returns the volume available at each price. All the price levels are retrieved with this channel. Each entry in bids and asks arrays is a price level, along with its price (px), quantity (qty) and number of orders (num) attributes.
-}
getL2OrderBook :
    { onSend : Result Http.Error OrderBook -> msg



    , symbol : String

    }
    -> Cmd msg
getL2OrderBook params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["l2", identity params.symbol]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend OrderBook.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


{-| Level 3 Order Book data is available through the l3 channel. This channel returns all the order updates reaching the exchange; by applying the updates to the snapshot you can recreate the full state of the orderbook. Each entry in bids and asks arrays is an order, along with its id (id), price (px) and quantity (qty) attributes.
-}
getL3OrderBook :
    { onSend : Result Http.Error OrderBook -> msg



    , symbol : String

    }
    -> Cmd msg
getL3OrderBook params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["l3", identity params.symbol]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend OrderBook.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


{-| When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
-}
getSymbolByName :
    { onSend : Result Http.Error SymbolStatus -> msg



    , symbol : String

    }
    -> Cmd msg
getSymbolByName params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["symbols", identity params.symbol]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend SymbolStatus.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


{-| When the symbol is not halted the auction data in the message may be blank. When a symbol is in a halt state the auction data will populate as the book builds. When an opening time has been chosen, the auction-time field will show the opening time. Subsequent updates will be sent only if the symbol status changes in any way.
-}
getSymbols :
    { onSend : Result Http.Error (Dict.Dict String SymbolStatus) -> msg





    }
    -> Cmd msg
getSymbols params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["symbols"]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend (Decode.dict SymbolStatus.decoder)
        , timeout = Just 30000
        , tracker = Nothing
        }


getTickerBySymbol :
    { onSend : Result Http.Error PriceEvent -> msg



    , symbol : String

    }
    -> Cmd msg
getTickerBySymbol params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["tickers", identity params.symbol]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend PriceEvent.decoder
        , timeout = Just 30000
        , tracker = Nothing
        }


getTickers :
    { onSend : Result Http.Error (List PriceEvent) -> msg





    }
    -> Cmd msg
getTickers params =
    Http.request
        { method = "GET"
        , headers = List.filterMap identity []
        , url = Url.crossOrigin basePath
            ["tickers"]
            (List.filterMap identity [])
        , body = Http.emptyBody
        , expect = Http.expectJson params.onSend (Decode.list PriceEvent.decoder)
        , timeout = Just 30000
        , tracker = Nothing
        }

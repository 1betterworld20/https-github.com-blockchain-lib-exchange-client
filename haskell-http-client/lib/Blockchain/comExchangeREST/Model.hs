{-
   Blockchain.com Exchange REST API

   ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. \\ These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account \\ Select API from the drop down menu \\ Fill out form and click “Create New API Key Now” \\ Once generated you can view your keys under API Settings. \\ Please be aware that the API key can only be used once it was verified via email.  The API key must be set via the \\ `X-API-Token`\\ header.  The base URL to be used for all calls is \\ `https://api.blockchain.com/v3/exchange`  Autogenerated clients for this API can be found [here](https://github.com/blockchain/lib-exchange-client). 

   OpenAPI Version: 3.0.0
   Blockchain.com Exchange REST API API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Blockchain.comExchangeREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Blockchain.comExchangeREST.Model where

import Blockchain.comExchangeREST.Core
import Blockchain.comExchangeREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Account
newtype Account = Account { unAccount :: Text } deriving (P.Eq, P.Show)

-- ** Currency2
newtype Currency2 = Currency2 { unCurrency2 :: Text } deriving (P.Eq, P.Show)

-- ** DepositId2
newtype DepositId2 = DepositId2 { unDepositId2 :: Text } deriving (P.Eq, P.Show)

-- ** From
newtype From = From { unFrom :: Integer } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** OrderId
newtype OrderId = OrderId { unOrderId :: Integer } deriving (P.Eq, P.Show)

-- ** Symbol2
newtype Symbol2 = Symbol2 { unSymbol2 :: Text } deriving (P.Eq, P.Show)

-- ** To
newtype To = To { unTo :: Integer } deriving (P.Eq, P.Show)

-- ** WithdrawalId2
newtype WithdrawalId2 = WithdrawalId2 { unWithdrawalId2 :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Balance
-- | Balance
data Balance = Balance
  { balanceCurrency :: !(Text) -- ^ /Required/ "currency"
  , balanceBalance :: !(Double) -- ^ /Required/ "balance"
  , balanceAvailable :: !(Double) -- ^ /Required/ "available"
  , balanceBalanceLocal :: !(Double) -- ^ /Required/ "balance_local"
  , balanceAvailableLocal :: !(Double) -- ^ /Required/ "available_local"
  , balanceRate :: !(Double) -- ^ /Required/ "rate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Balance
instance A.FromJSON Balance where
  parseJSON = A.withObject "Balance" $ \o ->
    Balance
      <$> (o .:  "currency")
      <*> (o .:  "balance")
      <*> (o .:  "available")
      <*> (o .:  "balance_local")
      <*> (o .:  "available_local")
      <*> (o .:  "rate")

-- | ToJSON Balance
instance A.ToJSON Balance where
  toJSON Balance {..} =
   _omitNulls
      [ "currency" .= balanceCurrency
      , "balance" .= balanceBalance
      , "available" .= balanceAvailable
      , "balance_local" .= balanceBalanceLocal
      , "available_local" .= balanceAvailableLocal
      , "rate" .= balanceRate
      ]


-- | Construct a value of type 'Balance' (by applying it's required fields, if any)
mkBalance
  :: Text -- ^ 'balanceCurrency' 
  -> Double -- ^ 'balanceBalance' 
  -> Double -- ^ 'balanceAvailable' 
  -> Double -- ^ 'balanceBalanceLocal' 
  -> Double -- ^ 'balanceAvailableLocal' 
  -> Double -- ^ 'balanceRate' 
  -> Balance
mkBalance balanceCurrency balanceBalance balanceAvailable balanceBalanceLocal balanceAvailableLocal balanceRate =
  Balance
  { balanceCurrency
  , balanceBalance
  , balanceAvailable
  , balanceBalanceLocal
  , balanceAvailableLocal
  , balanceRate
  }

-- ** BalanceMap
-- | BalanceMap
data BalanceMap = BalanceMap
  { balanceMapPrimary :: !([Balance]) -- ^ /Required/ "primary"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceMap
instance A.FromJSON BalanceMap where
  parseJSON = A.withObject "BalanceMap" $ \o ->
    BalanceMap
      <$> (o .:  "primary")

-- | ToJSON BalanceMap
instance A.ToJSON BalanceMap where
  toJSON BalanceMap {..} =
   _omitNulls
      [ "primary" .= balanceMapPrimary
      ]


-- | Construct a value of type 'BalanceMap' (by applying it's required fields, if any)
mkBalanceMap
  :: [Balance] -- ^ 'balanceMapPrimary' 
  -> BalanceMap
mkBalanceMap balanceMapPrimary =
  BalanceMap
  { balanceMapPrimary
  }

-- ** BaseOrder
-- | BaseOrder
data BaseOrder = BaseOrder
  { baseOrderClOrdId :: !(Text) -- ^ /Required/ "clOrdId" - Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
  , baseOrderOrdType :: !(OrdType) -- ^ /Required/ "ordType"
  , baseOrderSymbol :: !(Text) -- ^ /Required/ "symbol" - Blockchain symbol identifier
  , baseOrderSide :: !(Side) -- ^ /Required/ "side"
  , baseOrderOrderQty :: !(Double) -- ^ /Required/ "orderQty" - The order size in the terms of the base currency
  , baseOrderTimeInForce :: !(Maybe TimeInForce) -- ^ "timeInForce"
  , baseOrderPrice :: !(Maybe Double) -- ^ "price" - The limit price for the order
  , baseOrderExpireDate :: !(Maybe Int) -- ^ "expireDate" - expiry date in the format YYYYMMDD
  , baseOrderMinQty :: !(Maybe Double) -- ^ "minQty" - The minimum quantity required for an IOC fill
  , baseOrderStopPx :: !(Maybe Double) -- ^ "stopPx" - The limit price for the order
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseOrder
instance A.FromJSON BaseOrder where
  parseJSON = A.withObject "BaseOrder" $ \o ->
    BaseOrder
      <$> (o .:  "clOrdId")
      <*> (o .:  "ordType")
      <*> (o .:  "symbol")
      <*> (o .:  "side")
      <*> (o .:  "orderQty")
      <*> (o .:? "timeInForce")
      <*> (o .:? "price")
      <*> (o .:? "expireDate")
      <*> (o .:? "minQty")
      <*> (o .:? "stopPx")

-- | ToJSON BaseOrder
instance A.ToJSON BaseOrder where
  toJSON BaseOrder {..} =
   _omitNulls
      [ "clOrdId" .= baseOrderClOrdId
      , "ordType" .= baseOrderOrdType
      , "symbol" .= baseOrderSymbol
      , "side" .= baseOrderSide
      , "orderQty" .= baseOrderOrderQty
      , "timeInForce" .= baseOrderTimeInForce
      , "price" .= baseOrderPrice
      , "expireDate" .= baseOrderExpireDate
      , "minQty" .= baseOrderMinQty
      , "stopPx" .= baseOrderStopPx
      ]


-- | Construct a value of type 'BaseOrder' (by applying it's required fields, if any)
mkBaseOrder
  :: Text -- ^ 'baseOrderClOrdId': Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
  -> OrdType -- ^ 'baseOrderOrdType' 
  -> Text -- ^ 'baseOrderSymbol': Blockchain symbol identifier
  -> Side -- ^ 'baseOrderSide' 
  -> Double -- ^ 'baseOrderOrderQty': The order size in the terms of the base currency
  -> BaseOrder
mkBaseOrder baseOrderClOrdId baseOrderOrdType baseOrderSymbol baseOrderSide baseOrderOrderQty =
  BaseOrder
  { baseOrderClOrdId
  , baseOrderOrdType
  , baseOrderSymbol
  , baseOrderSide
  , baseOrderOrderQty
  , baseOrderTimeInForce = Nothing
  , baseOrderPrice = Nothing
  , baseOrderExpireDate = Nothing
  , baseOrderMinQty = Nothing
  , baseOrderStopPx = Nothing
  }

-- ** CancelOrderRequest
-- | CancelOrderRequest
data CancelOrderRequest = CancelOrderRequest
  { cancelOrderRequestAction :: !(E'Action) -- ^ /Required/ "action"
  , cancelOrderRequestOrderId :: !(Integer) -- ^ /Required/ "orderID" - The unique order id assigned by the exchange
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CancelOrderRequest
instance A.FromJSON CancelOrderRequest where
  parseJSON = A.withObject "CancelOrderRequest" $ \o ->
    CancelOrderRequest
      <$> (o .:  "action")
      <*> (o .:  "orderID")

-- | ToJSON CancelOrderRequest
instance A.ToJSON CancelOrderRequest where
  toJSON CancelOrderRequest {..} =
   _omitNulls
      [ "action" .= cancelOrderRequestAction
      , "orderID" .= cancelOrderRequestOrderId
      ]


-- | Construct a value of type 'CancelOrderRequest' (by applying it's required fields, if any)
mkCancelOrderRequest
  :: E'Action -- ^ 'cancelOrderRequestAction' 
  -> Integer -- ^ 'cancelOrderRequestOrderId': The unique order id assigned by the exchange
  -> CancelOrderRequest
mkCancelOrderRequest cancelOrderRequestAction cancelOrderRequestOrderId =
  CancelOrderRequest
  { cancelOrderRequestAction
  , cancelOrderRequestOrderId
  }

-- ** CreateWithdrawalRequest
-- | CreateWithdrawalRequest
data CreateWithdrawalRequest = CreateWithdrawalRequest
  { createWithdrawalRequestAmount :: !(Maybe Double) -- ^ "amount" - The amount to withdraw in the currency specified
  , createWithdrawalRequestCurrency :: !(Text) -- ^ /Required/ "currency"
  , createWithdrawalRequestBeneficiary :: !(Text) -- ^ /Required/ "beneficiary"
  , createWithdrawalRequestSendMax :: !(Maybe Bool) -- ^ "sendMax" - If set, sends the full available amount, minus fees. Amount may not be specified in that case. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateWithdrawalRequest
instance A.FromJSON CreateWithdrawalRequest where
  parseJSON = A.withObject "CreateWithdrawalRequest" $ \o ->
    CreateWithdrawalRequest
      <$> (o .:? "amount")
      <*> (o .:  "currency")
      <*> (o .:  "beneficiary")
      <*> (o .:? "sendMax")

-- | ToJSON CreateWithdrawalRequest
instance A.ToJSON CreateWithdrawalRequest where
  toJSON CreateWithdrawalRequest {..} =
   _omitNulls
      [ "amount" .= createWithdrawalRequestAmount
      , "currency" .= createWithdrawalRequestCurrency
      , "beneficiary" .= createWithdrawalRequestBeneficiary
      , "sendMax" .= createWithdrawalRequestSendMax
      ]


-- | Construct a value of type 'CreateWithdrawalRequest' (by applying it's required fields, if any)
mkCreateWithdrawalRequest
  :: Text -- ^ 'createWithdrawalRequestCurrency' 
  -> Text -- ^ 'createWithdrawalRequestBeneficiary' 
  -> CreateWithdrawalRequest
mkCreateWithdrawalRequest createWithdrawalRequestCurrency createWithdrawalRequestBeneficiary =
  CreateWithdrawalRequest
  { createWithdrawalRequestAmount = Nothing
  , createWithdrawalRequestCurrency
  , createWithdrawalRequestBeneficiary
  , createWithdrawalRequestSendMax = Nothing
  }

-- ** DepositAddressCrypto
-- | DepositAddressCrypto
data DepositAddressCrypto = DepositAddressCrypto
  { depositAddressCryptoType :: !(Text) -- ^ /Required/ "type"
  , depositAddressCryptoAddress :: !(Text) -- ^ /Required/ "address" - Address to deposit to. If a tag or memo must be used, it is separated by a colon.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositAddressCrypto
instance A.FromJSON DepositAddressCrypto where
  parseJSON = A.withObject "DepositAddressCrypto" $ \o ->
    DepositAddressCrypto
      <$> (o .:  "type")
      <*> (o .:  "address")

-- | ToJSON DepositAddressCrypto
instance A.ToJSON DepositAddressCrypto where
  toJSON DepositAddressCrypto {..} =
   _omitNulls
      [ "type" .= depositAddressCryptoType
      , "address" .= depositAddressCryptoAddress
      ]


-- | Construct a value of type 'DepositAddressCrypto' (by applying it's required fields, if any)
mkDepositAddressCrypto
  :: Text -- ^ 'depositAddressCryptoType' 
  -> Text -- ^ 'depositAddressCryptoAddress': Address to deposit to. If a tag or memo must be used, it is separated by a colon.
  -> DepositAddressCrypto
mkDepositAddressCrypto depositAddressCryptoType depositAddressCryptoAddress =
  DepositAddressCrypto
  { depositAddressCryptoType
  , depositAddressCryptoAddress
  }

-- ** DepositInfo
-- | DepositInfo
data DepositInfo = DepositInfo
  { depositInfoDepositId :: !(Text) -- ^ /Required/ "depositId" - Unique ID for this withdrawal
  , depositInfoAmount :: !(Double) -- ^ /Required/ "amount" - The amount that is credited in the currency specified
  , depositInfoCurrency :: !(Text) -- ^ /Required/ "currency"
  , depositInfoAddress :: !(Text) -- ^ /Required/ "address" - Address to deposit to. If a tag or memo must be used, it is separated by a colon.
  , depositInfoTxHash :: !(Maybe Text) -- ^ "txHash" - The transaction hash of the transaction that deposited funds
  , depositInfoState :: !(E'State) -- ^ /Required/ "state"
  , depositInfoTimestamp :: !(Maybe Integer) -- ^ "timestamp" - Time in ms since 01/01/1970 (epoch)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DepositInfo
instance A.FromJSON DepositInfo where
  parseJSON = A.withObject "DepositInfo" $ \o ->
    DepositInfo
      <$> (o .:  "depositId")
      <*> (o .:  "amount")
      <*> (o .:  "currency")
      <*> (o .:  "address")
      <*> (o .:? "txHash")
      <*> (o .:  "state")
      <*> (o .:? "timestamp")

-- | ToJSON DepositInfo
instance A.ToJSON DepositInfo where
  toJSON DepositInfo {..} =
   _omitNulls
      [ "depositId" .= depositInfoDepositId
      , "amount" .= depositInfoAmount
      , "currency" .= depositInfoCurrency
      , "address" .= depositInfoAddress
      , "txHash" .= depositInfoTxHash
      , "state" .= depositInfoState
      , "timestamp" .= depositInfoTimestamp
      ]


-- | Construct a value of type 'DepositInfo' (by applying it's required fields, if any)
mkDepositInfo
  :: Text -- ^ 'depositInfoDepositId': Unique ID for this withdrawal
  -> Double -- ^ 'depositInfoAmount': The amount that is credited in the currency specified
  -> Text -- ^ 'depositInfoCurrency' 
  -> Text -- ^ 'depositInfoAddress': Address to deposit to. If a tag or memo must be used, it is separated by a colon.
  -> E'State -- ^ 'depositInfoState' 
  -> DepositInfo
mkDepositInfo depositInfoDepositId depositInfoAmount depositInfoCurrency depositInfoAddress depositInfoState =
  DepositInfo
  { depositInfoDepositId
  , depositInfoAmount
  , depositInfoCurrency
  , depositInfoAddress
  , depositInfoTxHash = Nothing
  , depositInfoState
  , depositInfoTimestamp = Nothing
  }

-- ** Fees
-- | Fees
data Fees = Fees
  { feesMakerRate :: !(Double) -- ^ /Required/ "makerRate"
  , feesTakerRate :: !(Double) -- ^ /Required/ "takerRate"
  , feesVolumeInUsd :: !(Double) -- ^ /Required/ "volumeInUSD"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Fees
instance A.FromJSON Fees where
  parseJSON = A.withObject "Fees" $ \o ->
    Fees
      <$> (o .:  "makerRate")
      <*> (o .:  "takerRate")
      <*> (o .:  "volumeInUSD")

-- | ToJSON Fees
instance A.ToJSON Fees where
  toJSON Fees {..} =
   _omitNulls
      [ "makerRate" .= feesMakerRate
      , "takerRate" .= feesTakerRate
      , "volumeInUSD" .= feesVolumeInUsd
      ]


-- | Construct a value of type 'Fees' (by applying it's required fields, if any)
mkFees
  :: Double -- ^ 'feesMakerRate' 
  -> Double -- ^ 'feesTakerRate' 
  -> Double -- ^ 'feesVolumeInUsd' 
  -> Fees
mkFees feesMakerRate feesTakerRate feesVolumeInUsd =
  Fees
  { feesMakerRate
  , feesTakerRate
  , feesVolumeInUsd
  }

-- ** OrderBook
-- | OrderBook
data OrderBook = OrderBook
  { orderBookSymbol :: !(Maybe Text) -- ^ "symbol" - Blockchain symbol identifier
  , orderBookBids :: !(Maybe [OrderBookEntry]) -- ^ "bids"
  , orderBookAsks :: !(Maybe [OrderBookEntry]) -- ^ "asks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBook
instance A.FromJSON OrderBook where
  parseJSON = A.withObject "OrderBook" $ \o ->
    OrderBook
      <$> (o .:? "symbol")
      <*> (o .:? "bids")
      <*> (o .:? "asks")

-- | ToJSON OrderBook
instance A.ToJSON OrderBook where
  toJSON OrderBook {..} =
   _omitNulls
      [ "symbol" .= orderBookSymbol
      , "bids" .= orderBookBids
      , "asks" .= orderBookAsks
      ]


-- | Construct a value of type 'OrderBook' (by applying it's required fields, if any)
mkOrderBook
  :: OrderBook
mkOrderBook =
  OrderBook
  { orderBookSymbol = Nothing
  , orderBookBids = Nothing
  , orderBookAsks = Nothing
  }

-- ** OrderBookEntry
-- | OrderBookEntry
data OrderBookEntry = OrderBookEntry
  { orderBookEntryPx :: !(Maybe Double) -- ^ "px"
  , orderBookEntryQty :: !(Maybe Double) -- ^ "qty"
  , orderBookEntryNum :: !(Maybe Integer) -- ^ "num" - Either the quantity of orders on this price level for L2, or the individual order id for L3
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderBookEntry
instance A.FromJSON OrderBookEntry where
  parseJSON = A.withObject "OrderBookEntry" $ \o ->
    OrderBookEntry
      <$> (o .:? "px")
      <*> (o .:? "qty")
      <*> (o .:? "num")

-- | ToJSON OrderBookEntry
instance A.ToJSON OrderBookEntry where
  toJSON OrderBookEntry {..} =
   _omitNulls
      [ "px" .= orderBookEntryPx
      , "qty" .= orderBookEntryQty
      , "num" .= orderBookEntryNum
      ]


-- | Construct a value of type 'OrderBookEntry' (by applying it's required fields, if any)
mkOrderBookEntry
  :: OrderBookEntry
mkOrderBookEntry =
  OrderBookEntry
  { orderBookEntryPx = Nothing
  , orderBookEntryQty = Nothing
  , orderBookEntryNum = Nothing
  }

-- ** OrderSummary
-- | OrderSummary
data OrderSummary = OrderSummary
  { orderSummaryExOrdId :: !(Maybe Integer) -- ^ "exOrdId" - The unique order id assigned by the exchange
  , orderSummaryClOrdId :: !(Text) -- ^ /Required/ "clOrdId" - Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
  , orderSummaryOrdType :: !(OrdType) -- ^ /Required/ "ordType"
  , orderSummaryOrdStatus :: !(OrderStatus) -- ^ /Required/ "ordStatus"
  , orderSummarySide :: !(Side) -- ^ /Required/ "side"
  , orderSummaryPrice :: !(Maybe Double) -- ^ "price" - The limit price for the order
  , orderSummaryText :: !(Maybe Text) -- ^ "text" - The reason for rejecting the order, if applicable
  , orderSummarySymbol :: !(Text) -- ^ /Required/ "symbol" - Blockchain symbol identifier
  , orderSummaryLastShares :: !(Maybe Double) -- ^ "lastShares" - The executed quantity for the order&#39;s last fill
  , orderSummaryLastPx :: !(Maybe Double) -- ^ "lastPx" - The executed price for the last fill
  , orderSummaryLeavesQty :: !(Maybe Double) -- ^ "leavesQty" - For Open and Partially Filled orders this is the remaining quantity open for execution. For Canceled and Expired orders this is the quantity than was still open before cancellation/expiration. For Rejected order this is equal to orderQty. For other states this is always zero.
  , orderSummaryCumQty :: !(Maybe Double) -- ^ "cumQty" - The quantity of the order which has been filled
  , orderSummaryAvgPx :: !(Maybe Double) -- ^ "avgPx" - Calculated the Volume Weighted Average Price of all fills for this order
  , orderSummaryTimestamp :: !(Maybe Integer) -- ^ "timestamp" - Time in ms since 01/01/1970 (epoch)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderSummary
instance A.FromJSON OrderSummary where
  parseJSON = A.withObject "OrderSummary" $ \o ->
    OrderSummary
      <$> (o .:? "exOrdId")
      <*> (o .:  "clOrdId")
      <*> (o .:  "ordType")
      <*> (o .:  "ordStatus")
      <*> (o .:  "side")
      <*> (o .:? "price")
      <*> (o .:? "text")
      <*> (o .:  "symbol")
      <*> (o .:? "lastShares")
      <*> (o .:? "lastPx")
      <*> (o .:? "leavesQty")
      <*> (o .:? "cumQty")
      <*> (o .:? "avgPx")
      <*> (o .:? "timestamp")

-- | ToJSON OrderSummary
instance A.ToJSON OrderSummary where
  toJSON OrderSummary {..} =
   _omitNulls
      [ "exOrdId" .= orderSummaryExOrdId
      , "clOrdId" .= orderSummaryClOrdId
      , "ordType" .= orderSummaryOrdType
      , "ordStatus" .= orderSummaryOrdStatus
      , "side" .= orderSummarySide
      , "price" .= orderSummaryPrice
      , "text" .= orderSummaryText
      , "symbol" .= orderSummarySymbol
      , "lastShares" .= orderSummaryLastShares
      , "lastPx" .= orderSummaryLastPx
      , "leavesQty" .= orderSummaryLeavesQty
      , "cumQty" .= orderSummaryCumQty
      , "avgPx" .= orderSummaryAvgPx
      , "timestamp" .= orderSummaryTimestamp
      ]


-- | Construct a value of type 'OrderSummary' (by applying it's required fields, if any)
mkOrderSummary
  :: Text -- ^ 'orderSummaryClOrdId': Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
  -> OrdType -- ^ 'orderSummaryOrdType' 
  -> OrderStatus -- ^ 'orderSummaryOrdStatus' 
  -> Side -- ^ 'orderSummarySide' 
  -> Text -- ^ 'orderSummarySymbol': Blockchain symbol identifier
  -> OrderSummary
mkOrderSummary orderSummaryClOrdId orderSummaryOrdType orderSummaryOrdStatus orderSummarySide orderSummarySymbol =
  OrderSummary
  { orderSummaryExOrdId = Nothing
  , orderSummaryClOrdId
  , orderSummaryOrdType
  , orderSummaryOrdStatus
  , orderSummarySide
  , orderSummaryPrice = Nothing
  , orderSummaryText = Nothing
  , orderSummarySymbol
  , orderSummaryLastShares = Nothing
  , orderSummaryLastPx = Nothing
  , orderSummaryLeavesQty = Nothing
  , orderSummaryCumQty = Nothing
  , orderSummaryAvgPx = Nothing
  , orderSummaryTimestamp = Nothing
  }

-- ** PriceEvent
-- | PriceEvent
data PriceEvent = PriceEvent
  { priceEventSymbol :: !(Maybe Text) -- ^ "symbol" - Blockchain symbol identifier
  , priceEventPrice24h :: !(Maybe Double) -- ^ "price_24h"
  , priceEventVolume24h :: !(Maybe Double) -- ^ "volume_24h"
  , priceEventLastTradePrice :: !(Maybe Double) -- ^ "last_trade_price"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceEvent
instance A.FromJSON PriceEvent where
  parseJSON = A.withObject "PriceEvent" $ \o ->
    PriceEvent
      <$> (o .:? "symbol")
      <*> (o .:? "price_24h")
      <*> (o .:? "volume_24h")
      <*> (o .:? "last_trade_price")

-- | ToJSON PriceEvent
instance A.ToJSON PriceEvent where
  toJSON PriceEvent {..} =
   _omitNulls
      [ "symbol" .= priceEventSymbol
      , "price_24h" .= priceEventPrice24h
      , "volume_24h" .= priceEventVolume24h
      , "last_trade_price" .= priceEventLastTradePrice
      ]


-- | Construct a value of type 'PriceEvent' (by applying it's required fields, if any)
mkPriceEvent
  :: PriceEvent
mkPriceEvent =
  PriceEvent
  { priceEventSymbol = Nothing
  , priceEventPrice24h = Nothing
  , priceEventVolume24h = Nothing
  , priceEventLastTradePrice = Nothing
  }

-- ** PriceEventList
-- | PriceEventList
data PriceEventList = PriceEventList
  { priceEventListOrders :: !(Maybe [PriceEvent]) -- ^ "orders"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PriceEventList
instance A.FromJSON PriceEventList where
  parseJSON = A.withObject "PriceEventList" $ \o ->
    PriceEventList
      <$> (o .:? "orders")

-- | ToJSON PriceEventList
instance A.ToJSON PriceEventList where
  toJSON PriceEventList {..} =
   _omitNulls
      [ "orders" .= priceEventListOrders
      ]


-- | Construct a value of type 'PriceEventList' (by applying it's required fields, if any)
mkPriceEventList
  :: PriceEventList
mkPriceEventList =
  PriceEventList
  { priceEventListOrders = Nothing
  }

-- ** SymbolStatus
-- | SymbolStatus
data SymbolStatus = SymbolStatus
  { symbolStatusBaseCurrency :: !(Maybe Text) -- ^ "base_currency" - Blockchain symbol identifier
  , symbolStatusBaseCurrencyScale :: !(Maybe Int) -- ^ "base_currency_scale" - The number of decimals the currency can be split in
  , symbolStatusCounterCurrency :: !(Maybe Text) -- ^ "counter_currency" - Blockchain symbol identifier
  , symbolStatusCounterCurrencyScale :: !(Maybe Int) -- ^ "counter_currency_scale" - The number of decimals the currency can be split in
  , symbolStatusMinPriceIncrement :: !(Maybe Integer) -- ^ "min_price_increment" - The price of the instrument must be a multiple of min_price_increment * (10^-min_price_increment_scale)
  , symbolStatusMinPriceIncrementScale :: !(Maybe Int) -- ^ "min_price_increment_scale"
  , symbolStatusMinOrderSize :: !(Maybe Integer) -- ^ "min_order_size" - The minimum quantity for an order for this instrument must be min_order_size*(10^-min_order_size_scale)
  , symbolStatusMinOrderSizeScale :: !(Maybe Int) -- ^ "min_order_size_scale"
  , symbolStatusMaxOrderSize :: !(Maybe Integer) -- ^ "max_order_size" - The maximum quantity for an order for this instrument is max_order_size*(10^-max_order_size_scale). If this equal to zero, there is no limit
  , symbolStatusMaxOrderSizeScale :: !(Maybe Int) -- ^ "max_order_size_scale"
  , symbolStatusLotSize :: !(Maybe Integer) -- ^ "lot_size"
  , symbolStatusLotSizeScale :: !(Maybe Int) -- ^ "lot_size_scale"
  , symbolStatusStatus :: !(Maybe E'Status) -- ^ "status" - Symbol status; open, close, suspend, halt, halt-freeze.
  , symbolStatusId :: !(Maybe Integer) -- ^ "id"
  , symbolStatusAuctionPrice :: !(Maybe Double) -- ^ "auction_price" - If the symbol is halted and will open on an auction, this will be the opening price.
  , symbolStatusAuctionSize :: !(Maybe Double) -- ^ "auction_size" - Opening size
  , symbolStatusAuctionTime :: !(Maybe Text) -- ^ "auction_time" - Opening time in HHMM format
  , symbolStatusImbalance :: !(Maybe Double) -- ^ "imbalance" - Auction imbalance. If &gt; 0 then there will be buy orders left over at the auction price. If &lt; 0 then there will be sell orders left over at the auction price.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SymbolStatus
instance A.FromJSON SymbolStatus where
  parseJSON = A.withObject "SymbolStatus" $ \o ->
    SymbolStatus
      <$> (o .:? "base_currency")
      <*> (o .:? "base_currency_scale")
      <*> (o .:? "counter_currency")
      <*> (o .:? "counter_currency_scale")
      <*> (o .:? "min_price_increment")
      <*> (o .:? "min_price_increment_scale")
      <*> (o .:? "min_order_size")
      <*> (o .:? "min_order_size_scale")
      <*> (o .:? "max_order_size")
      <*> (o .:? "max_order_size_scale")
      <*> (o .:? "lot_size")
      <*> (o .:? "lot_size_scale")
      <*> (o .:? "status")
      <*> (o .:? "id")
      <*> (o .:? "auction_price")
      <*> (o .:? "auction_size")
      <*> (o .:? "auction_time")
      <*> (o .:? "imbalance")

-- | ToJSON SymbolStatus
instance A.ToJSON SymbolStatus where
  toJSON SymbolStatus {..} =
   _omitNulls
      [ "base_currency" .= symbolStatusBaseCurrency
      , "base_currency_scale" .= symbolStatusBaseCurrencyScale
      , "counter_currency" .= symbolStatusCounterCurrency
      , "counter_currency_scale" .= symbolStatusCounterCurrencyScale
      , "min_price_increment" .= symbolStatusMinPriceIncrement
      , "min_price_increment_scale" .= symbolStatusMinPriceIncrementScale
      , "min_order_size" .= symbolStatusMinOrderSize
      , "min_order_size_scale" .= symbolStatusMinOrderSizeScale
      , "max_order_size" .= symbolStatusMaxOrderSize
      , "max_order_size_scale" .= symbolStatusMaxOrderSizeScale
      , "lot_size" .= symbolStatusLotSize
      , "lot_size_scale" .= symbolStatusLotSizeScale
      , "status" .= symbolStatusStatus
      , "id" .= symbolStatusId
      , "auction_price" .= symbolStatusAuctionPrice
      , "auction_size" .= symbolStatusAuctionSize
      , "auction_time" .= symbolStatusAuctionTime
      , "imbalance" .= symbolStatusImbalance
      ]


-- | Construct a value of type 'SymbolStatus' (by applying it's required fields, if any)
mkSymbolStatus
  :: SymbolStatus
mkSymbolStatus =
  SymbolStatus
  { symbolStatusBaseCurrency = Nothing
  , symbolStatusBaseCurrencyScale = Nothing
  , symbolStatusCounterCurrency = Nothing
  , symbolStatusCounterCurrencyScale = Nothing
  , symbolStatusMinPriceIncrement = Nothing
  , symbolStatusMinPriceIncrementScale = Nothing
  , symbolStatusMinOrderSize = Nothing
  , symbolStatusMinOrderSizeScale = Nothing
  , symbolStatusMaxOrderSize = Nothing
  , symbolStatusMaxOrderSizeScale = Nothing
  , symbolStatusLotSize = Nothing
  , symbolStatusLotSizeScale = Nothing
  , symbolStatusStatus = Nothing
  , symbolStatusId = Nothing
  , symbolStatusAuctionPrice = Nothing
  , symbolStatusAuctionSize = Nothing
  , symbolStatusAuctionTime = Nothing
  , symbolStatusImbalance = Nothing
  }

-- ** UnauthorizedError
-- | UnauthorizedError
-- API key is missing or invalid
data UnauthorizedError = UnauthorizedError
  { unauthorizedErrorError :: !(Maybe Text) -- ^ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UnauthorizedError
instance A.FromJSON UnauthorizedError where
  parseJSON = A.withObject "UnauthorizedError" $ \o ->
    UnauthorizedError
      <$> (o .:? "error")

-- | ToJSON UnauthorizedError
instance A.ToJSON UnauthorizedError where
  toJSON UnauthorizedError {..} =
   _omitNulls
      [ "error" .= unauthorizedErrorError
      ]


-- | Construct a value of type 'UnauthorizedError' (by applying it's required fields, if any)
mkUnauthorizedError
  :: UnauthorizedError
mkUnauthorizedError =
  UnauthorizedError
  { unauthorizedErrorError = Nothing
  }

-- ** WhitelistEntry
-- | WhitelistEntry
data WhitelistEntry = WhitelistEntry
  { whitelistEntryWhitelistId :: !(Maybe Text) -- ^ "whitelistId" - Unique ID for each whitelist entry
  , whitelistEntryName :: !(Maybe Text) -- ^ "name" - User specified name for this entry
  , whitelistEntryCurrency :: !(Maybe Text) -- ^ "currency"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WhitelistEntry
instance A.FromJSON WhitelistEntry where
  parseJSON = A.withObject "WhitelistEntry" $ \o ->
    WhitelistEntry
      <$> (o .:? "whitelistId")
      <*> (o .:? "name")
      <*> (o .:? "currency")

-- | ToJSON WhitelistEntry
instance A.ToJSON WhitelistEntry where
  toJSON WhitelistEntry {..} =
   _omitNulls
      [ "whitelistId" .= whitelistEntryWhitelistId
      , "name" .= whitelistEntryName
      , "currency" .= whitelistEntryCurrency
      ]


-- | Construct a value of type 'WhitelistEntry' (by applying it's required fields, if any)
mkWhitelistEntry
  :: WhitelistEntry
mkWhitelistEntry =
  WhitelistEntry
  { whitelistEntryWhitelistId = Nothing
  , whitelistEntryName = Nothing
  , whitelistEntryCurrency = Nothing
  }

-- ** WithdrawalInfo
-- | WithdrawalInfo
data WithdrawalInfo = WithdrawalInfo
  { withdrawalInfoWithdrawalId :: !(Maybe Text) -- ^ "withdrawalId" - Unique ID for this withdrawal
  , withdrawalInfoAmount :: !(Double) -- ^ /Required/ "amount" - The amount to withdraw in the currency specified
  , withdrawalInfoFee :: !(Maybe Double) -- ^ "fee" - The amount charged in fees for this withdrawal
  , withdrawalInfoCurrency :: !(Text) -- ^ /Required/ "currency"
  , withdrawalInfoBeneficiary :: !(Text) -- ^ /Required/ "beneficiary"
  , withdrawalInfoState :: !(Maybe WithdrawalStatus) -- ^ "state"
  , withdrawalInfoTimestamp :: !(Maybe Integer) -- ^ "timestamp" - Time in ms since 01/01/1970 (epoch)
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WithdrawalInfo
instance A.FromJSON WithdrawalInfo where
  parseJSON = A.withObject "WithdrawalInfo" $ \o ->
    WithdrawalInfo
      <$> (o .:? "withdrawalId")
      <*> (o .:  "amount")
      <*> (o .:? "fee")
      <*> (o .:  "currency")
      <*> (o .:  "beneficiary")
      <*> (o .:? "state")
      <*> (o .:? "timestamp")

-- | ToJSON WithdrawalInfo
instance A.ToJSON WithdrawalInfo where
  toJSON WithdrawalInfo {..} =
   _omitNulls
      [ "withdrawalId" .= withdrawalInfoWithdrawalId
      , "amount" .= withdrawalInfoAmount
      , "fee" .= withdrawalInfoFee
      , "currency" .= withdrawalInfoCurrency
      , "beneficiary" .= withdrawalInfoBeneficiary
      , "state" .= withdrawalInfoState
      , "timestamp" .= withdrawalInfoTimestamp
      ]


-- | Construct a value of type 'WithdrawalInfo' (by applying it's required fields, if any)
mkWithdrawalInfo
  :: Double -- ^ 'withdrawalInfoAmount': The amount to withdraw in the currency specified
  -> Text -- ^ 'withdrawalInfoCurrency' 
  -> Text -- ^ 'withdrawalInfoBeneficiary' 
  -> WithdrawalInfo
mkWithdrawalInfo withdrawalInfoAmount withdrawalInfoCurrency withdrawalInfoBeneficiary =
  WithdrawalInfo
  { withdrawalInfoWithdrawalId = Nothing
  , withdrawalInfoAmount
  , withdrawalInfoFee = Nothing
  , withdrawalInfoCurrency
  , withdrawalInfoBeneficiary
  , withdrawalInfoState = Nothing
  , withdrawalInfoTimestamp = Nothing
  }


-- * Enums


-- ** E'Action

-- | Enum of 'Text'
data E'Action
  = E'Action'CancelOrderRequest -- ^ @"CancelOrderRequest"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Action where toJSON = A.toJSON . fromE'Action
instance A.FromJSON E'Action where parseJSON o = P.either P.fail (pure . P.id) . toE'Action =<< A.parseJSON o
instance WH.ToHttpApiData E'Action where toQueryParam = WH.toQueryParam . fromE'Action
instance WH.FromHttpApiData E'Action where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Action
instance MimeRender MimeMultipartFormData E'Action where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Action' enum
fromE'Action :: E'Action -> Text
fromE'Action = \case
  E'Action'CancelOrderRequest -> "CancelOrderRequest"

-- | parse 'E'Action' enum
toE'Action :: Text -> P.Either String E'Action
toE'Action = \case
  "CancelOrderRequest" -> P.Right E'Action'CancelOrderRequest
  s -> P.Left $ "toE'Action: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'REJECTED -- ^ @"REJECTED"@
  | E'State'UNCONFIRMED -- ^ @"UNCONFIRMED"@
  | E'State'COMPLETED -- ^ @"COMPLETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'REJECTED -> "REJECTED"
  E'State'UNCONFIRMED -> "UNCONFIRMED"
  E'State'COMPLETED -> "COMPLETED"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "REJECTED" -> P.Right E'State'REJECTED
  "UNCONFIRMED" -> P.Right E'State'UNCONFIRMED
  "COMPLETED" -> P.Right E'State'COMPLETED
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' . 
-- Symbol status; open, close, suspend, halt, halt-freeze.
data E'Status
  = E'Status'Open -- ^ @"open"@
  | E'Status'Close -- ^ @"close"@
  | E'Status'Suspend -- ^ @"suspend"@
  | E'Status'Halt -- ^ @"halt"@
  | E'Status'Halt_freeze -- ^ @"halt-freeze"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Open -> "open"
  E'Status'Close -> "close"
  E'Status'Suspend -> "suspend"
  E'Status'Halt -> "halt"
  E'Status'Halt_freeze -> "halt-freeze"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "open" -> P.Right E'Status'Open
  "close" -> P.Right E'Status'Close
  "suspend" -> P.Right E'Status'Suspend
  "halt" -> P.Right E'Status'Halt
  "halt-freeze" -> P.Right E'Status'Halt_freeze
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** OrdType

-- | Enum of 'Text'
data OrdType
  = OrdType'MARKET -- ^ @"MARKET"@
  | OrdType'LIMIT -- ^ @"LIMIT"@
  | OrdType'STOP -- ^ @"STOP"@
  | OrdType'STOPLIMIT -- ^ @"STOPLIMIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdType where toJSON = A.toJSON . fromOrdType
instance A.FromJSON OrdType where parseJSON o = P.either P.fail (pure . P.id) . toOrdType =<< A.parseJSON o
instance WH.ToHttpApiData OrdType where toQueryParam = WH.toQueryParam . fromOrdType
instance WH.FromHttpApiData OrdType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdType
instance MimeRender MimeMultipartFormData OrdType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdType' enum
fromOrdType :: OrdType -> Text
fromOrdType = \case
  OrdType'MARKET -> "MARKET"
  OrdType'LIMIT -> "LIMIT"
  OrdType'STOP -> "STOP"
  OrdType'STOPLIMIT -> "STOPLIMIT"

-- | parse 'OrdType' enum
toOrdType :: Text -> P.Either String OrdType
toOrdType = \case
  "MARKET" -> P.Right OrdType'MARKET
  "LIMIT" -> P.Right OrdType'LIMIT
  "STOP" -> P.Right OrdType'STOP
  "STOPLIMIT" -> P.Right OrdType'STOPLIMIT
  s -> P.Left $ "toOrdType: enum parse failure: " P.++ P.show s


-- ** OrderStatus

-- | Enum of 'Text'
data OrderStatus
  = OrderStatus'OPEN -- ^ @"OPEN"@
  | OrderStatus'REJECTED -- ^ @"REJECTED"@
  | OrderStatus'CANCELED -- ^ @"CANCELED"@
  | OrderStatus'FILLED -- ^ @"FILLED"@
  | OrderStatus'PART_FILLED -- ^ @"PART_FILLED"@
  | OrderStatus'EXPIRED -- ^ @"EXPIRED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderStatus where toJSON = A.toJSON . fromOrderStatus
instance A.FromJSON OrderStatus where parseJSON o = P.either P.fail (pure . P.id) . toOrderStatus =<< A.parseJSON o
instance WH.ToHttpApiData OrderStatus where toQueryParam = WH.toQueryParam . fromOrderStatus
instance WH.FromHttpApiData OrderStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderStatus
instance MimeRender MimeMultipartFormData OrderStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderStatus' enum
fromOrderStatus :: OrderStatus -> Text
fromOrderStatus = \case
  OrderStatus'OPEN -> "OPEN"
  OrderStatus'REJECTED -> "REJECTED"
  OrderStatus'CANCELED -> "CANCELED"
  OrderStatus'FILLED -> "FILLED"
  OrderStatus'PART_FILLED -> "PART_FILLED"
  OrderStatus'EXPIRED -> "EXPIRED"

-- | parse 'OrderStatus' enum
toOrderStatus :: Text -> P.Either String OrderStatus
toOrderStatus = \case
  "OPEN" -> P.Right OrderStatus'OPEN
  "REJECTED" -> P.Right OrderStatus'REJECTED
  "CANCELED" -> P.Right OrderStatus'CANCELED
  "FILLED" -> P.Right OrderStatus'FILLED
  "PART_FILLED" -> P.Right OrderStatus'PART_FILLED
  "EXPIRED" -> P.Right OrderStatus'EXPIRED
  s -> P.Left $ "toOrderStatus: enum parse failure: " P.++ P.show s


-- ** Side

-- | Enum of 'Text' . 
-- \"buy\" for Buy, \"sell\" for Sell
data Side
  = Side'BUY -- ^ @"BUY"@
  | Side'SELL -- ^ @"SELL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Side where toJSON = A.toJSON . fromSide
instance A.FromJSON Side where parseJSON o = P.either P.fail (pure . P.id) . toSide =<< A.parseJSON o
instance WH.ToHttpApiData Side where toQueryParam = WH.toQueryParam . fromSide
instance WH.FromHttpApiData Side where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSide
instance MimeRender MimeMultipartFormData Side where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Side' enum
fromSide :: Side -> Text
fromSide = \case
  Side'BUY -> "BUY"
  Side'SELL -> "SELL"

-- | parse 'Side' enum
toSide :: Text -> P.Either String Side
toSide = \case
  "BUY" -> P.Right Side'BUY
  "SELL" -> P.Right Side'SELL
  s -> P.Left $ "toSide: enum parse failure: " P.++ P.show s


-- ** TimeInForce

-- | Enum of 'Text' . 
-- \"GTC\" for Good Till Cancel, \"IOC\" for Immediate or Cancel, \"FOK\" for Fill or Kill, \"GTD\" Good Till Date
data TimeInForce
  = TimeInForce'GTC -- ^ @"GTC"@
  | TimeInForce'IOC -- ^ @"IOC"@
  | TimeInForce'FOK -- ^ @"FOK"@
  | TimeInForce'GTD -- ^ @"GTD"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForce where toJSON = A.toJSON . fromTimeInForce
instance A.FromJSON TimeInForce where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForce =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForce where toQueryParam = WH.toQueryParam . fromTimeInForce
instance WH.FromHttpApiData TimeInForce where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForce
instance MimeRender MimeMultipartFormData TimeInForce where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForce' enum
fromTimeInForce :: TimeInForce -> Text
fromTimeInForce = \case
  TimeInForce'GTC -> "GTC"
  TimeInForce'IOC -> "IOC"
  TimeInForce'FOK -> "FOK"
  TimeInForce'GTD -> "GTD"

-- | parse 'TimeInForce' enum
toTimeInForce :: Text -> P.Either String TimeInForce
toTimeInForce = \case
  "GTC" -> P.Right TimeInForce'GTC
  "IOC" -> P.Right TimeInForce'IOC
  "FOK" -> P.Right TimeInForce'FOK
  "GTD" -> P.Right TimeInForce'GTD
  s -> P.Left $ "toTimeInForce: enum parse failure: " P.++ P.show s


-- ** TimeInForceStop

-- | Enum of 'Text' . 
-- \"GTC\" for Good Till Cancel, \"GTD\" Good Till Date
data TimeInForceStop
  = TimeInForceStop'GTC -- ^ @"GTC"@
  | TimeInForceStop'GTD -- ^ @"GTD"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForceStop where toJSON = A.toJSON . fromTimeInForceStop
instance A.FromJSON TimeInForceStop where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForceStop =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForceStop where toQueryParam = WH.toQueryParam . fromTimeInForceStop
instance WH.FromHttpApiData TimeInForceStop where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForceStop
instance MimeRender MimeMultipartFormData TimeInForceStop where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForceStop' enum
fromTimeInForceStop :: TimeInForceStop -> Text
fromTimeInForceStop = \case
  TimeInForceStop'GTC -> "GTC"
  TimeInForceStop'GTD -> "GTD"

-- | parse 'TimeInForceStop' enum
toTimeInForceStop :: Text -> P.Either String TimeInForceStop
toTimeInForceStop = \case
  "GTC" -> P.Right TimeInForceStop'GTC
  "GTD" -> P.Right TimeInForceStop'GTD
  s -> P.Left $ "toTimeInForceStop: enum parse failure: " P.++ P.show s


-- ** WithdrawalStatus

-- | Enum of 'Text'
data WithdrawalStatus
  = WithdrawalStatus'REJECTED -- ^ @"REJECTED"@
  | WithdrawalStatus'PENDING -- ^ @"PENDING"@
  | WithdrawalStatus'REFUNDED -- ^ @"REFUNDED"@
  | WithdrawalStatus'FAILED -- ^ @"FAILED"@
  | WithdrawalStatus'COMPLETED -- ^ @"COMPLETED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON WithdrawalStatus where toJSON = A.toJSON . fromWithdrawalStatus
instance A.FromJSON WithdrawalStatus where parseJSON o = P.either P.fail (pure . P.id) . toWithdrawalStatus =<< A.parseJSON o
instance WH.ToHttpApiData WithdrawalStatus where toQueryParam = WH.toQueryParam . fromWithdrawalStatus
instance WH.FromHttpApiData WithdrawalStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toWithdrawalStatus
instance MimeRender MimeMultipartFormData WithdrawalStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'WithdrawalStatus' enum
fromWithdrawalStatus :: WithdrawalStatus -> Text
fromWithdrawalStatus = \case
  WithdrawalStatus'REJECTED -> "REJECTED"
  WithdrawalStatus'PENDING -> "PENDING"
  WithdrawalStatus'REFUNDED -> "REFUNDED"
  WithdrawalStatus'FAILED -> "FAILED"
  WithdrawalStatus'COMPLETED -> "COMPLETED"

-- | parse 'WithdrawalStatus' enum
toWithdrawalStatus :: Text -> P.Either String WithdrawalStatus
toWithdrawalStatus = \case
  "REJECTED" -> P.Right WithdrawalStatus'REJECTED
  "PENDING" -> P.Right WithdrawalStatus'PENDING
  "REFUNDED" -> P.Right WithdrawalStatus'REFUNDED
  "FAILED" -> P.Right WithdrawalStatus'FAILED
  "COMPLETED" -> P.Right WithdrawalStatus'COMPLETED
  s -> P.Left $ "toWithdrawalStatus: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKeyAuth
data AuthApiKeyApiKeyAuth =
  AuthApiKeyApiKeyAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKeyAuth where
  applyAuthMethod _ a@(AuthApiKeyApiKeyAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-Token", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req



/* 
 * Blockchain.com Exchange REST API
 *
 * ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account Select API from the drop down menu Fill out form and click “Create New API Key Now” Once generated you can view your keys under API Settings 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.com.blockchain.exchange.rest.model
{
    /// <summary>
    /// BaseOrder
    /// </summary>
    [DataContract]
    public partial class BaseOrder :  IEquatable<BaseOrder>, IValidatableObject
    {
        /// <summary>
        /// Defines OrdType
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum OrdTypeEnum
        {
            /// <summary>
            /// Enum MARKET for value: MARKET
            /// </summary>
            [EnumMember(Value = "MARKET")]
            MARKET = 1,

            /// <summary>
            /// Enum LIMIT for value: LIMIT
            /// </summary>
            [EnumMember(Value = "LIMIT")]
            LIMIT = 2,

            /// <summary>
            /// Enum STOP for value: STOP
            /// </summary>
            [EnumMember(Value = "STOP")]
            STOP = 3,

            /// <summary>
            /// Enum STOPLIMIT for value: STOPLIMIT
            /// </summary>
            [EnumMember(Value = "STOPLIMIT")]
            STOPLIMIT = 4

        }

        /// <summary>
        /// Gets or Sets OrdType
        /// </summary>
        [DataMember(Name="ordType", EmitDefaultValue=false)]
        public OrdTypeEnum? OrdType { get; set; }
        /// <summary>
        /// Gets or Sets TimeInForce
        /// </summary>
        [DataMember(Name="timeInForce", EmitDefaultValue=false)]
        public TimeInForce? TimeInForce { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="BaseOrder" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected BaseOrder() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BaseOrder" /> class.
        /// </summary>
        /// <param name="ordType">ordType.</param>
        /// <param name="clOrdId">Reference field provided by client and cannot exceed 20 characters (required).</param>
        /// <param name="symbol">Blockchain symbol identifier (required).</param>
        /// <param name="side">side (required).</param>
        /// <param name="orderQty">The order size in the terms of the base currency (required).</param>
        /// <param name="timeInForce">timeInForce.</param>
        /// <param name="price">The limit price for the order.</param>
        /// <param name="expireDate">expiry date in the format YYYYMMDD.</param>
        /// <param name="minQty">The minimum quantity required for an IOC fill.</param>
        /// <param name="stopPx">The limit price for the order.</param>
        public BaseOrder(OrdTypeEnum? ordType = default(OrdTypeEnum?), string clOrdId = default(string), string symbol = default(string), Side side = default(Side), double orderQty = default(double), TimeInForce? timeInForce = default(TimeInForce?), double price = default(double), int expireDate = default(int), double minQty = default(double), double stopPx = default(double))
        {
            // to ensure "clOrdId" is required (not null)
            if (clOrdId == null)
            {
                throw new InvalidDataException("clOrdId is a required property for BaseOrder and cannot be null");
            }
            else
            {
                this.ClOrdId = clOrdId;
            }
            
            // to ensure "symbol" is required (not null)
            if (symbol == null)
            {
                throw new InvalidDataException("symbol is a required property for BaseOrder and cannot be null");
            }
            else
            {
                this.Symbol = symbol;
            }
            
            // to ensure "side" is required (not null)
            if (side == null)
            {
                throw new InvalidDataException("side is a required property for BaseOrder and cannot be null");
            }
            else
            {
                this.Side = side;
            }
            
            // to ensure "orderQty" is required (not null)
            if (orderQty == null)
            {
                throw new InvalidDataException("orderQty is a required property for BaseOrder and cannot be null");
            }
            else
            {
                this.OrderQty = orderQty;
            }
            
            this.OrdType = ordType;
            this.TimeInForce = timeInForce;
            this.Price = price;
            this.ExpireDate = expireDate;
            this.MinQty = minQty;
            this.StopPx = stopPx;
        }
        

        /// <summary>
        /// Reference field provided by client and cannot exceed 20 characters
        /// </summary>
        /// <value>Reference field provided by client and cannot exceed 20 characters</value>
        [DataMember(Name="clOrdId", EmitDefaultValue=true)]
        public string ClOrdId { get; set; }

        /// <summary>
        /// Blockchain symbol identifier
        /// </summary>
        /// <value>Blockchain symbol identifier</value>
        [DataMember(Name="symbol", EmitDefaultValue=true)]
        public string Symbol { get; set; }

        /// <summary>
        /// Gets or Sets Side
        /// </summary>
        [DataMember(Name="side", EmitDefaultValue=true)]
        public Side Side { get; set; }

        /// <summary>
        /// The order size in the terms of the base currency
        /// </summary>
        /// <value>The order size in the terms of the base currency</value>
        [DataMember(Name="orderQty", EmitDefaultValue=true)]
        public double OrderQty { get; set; }


        /// <summary>
        /// The limit price for the order
        /// </summary>
        /// <value>The limit price for the order</value>
        [DataMember(Name="price", EmitDefaultValue=false)]
        public double Price { get; set; }

        /// <summary>
        /// expiry date in the format YYYYMMDD
        /// </summary>
        /// <value>expiry date in the format YYYYMMDD</value>
        [DataMember(Name="expireDate", EmitDefaultValue=false)]
        public int ExpireDate { get; set; }

        /// <summary>
        /// The minimum quantity required for an IOC fill
        /// </summary>
        /// <value>The minimum quantity required for an IOC fill</value>
        [DataMember(Name="minQty", EmitDefaultValue=false)]
        public double MinQty { get; set; }

        /// <summary>
        /// The limit price for the order
        /// </summary>
        /// <value>The limit price for the order</value>
        [DataMember(Name="stopPx", EmitDefaultValue=false)]
        public double StopPx { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class BaseOrder {\n");
            sb.Append("  OrdType: ").Append(OrdType).Append("\n");
            sb.Append("  ClOrdId: ").Append(ClOrdId).Append("\n");
            sb.Append("  Symbol: ").Append(Symbol).Append("\n");
            sb.Append("  Side: ").Append(Side).Append("\n");
            sb.Append("  OrderQty: ").Append(OrderQty).Append("\n");
            sb.Append("  TimeInForce: ").Append(TimeInForce).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  ExpireDate: ").Append(ExpireDate).Append("\n");
            sb.Append("  MinQty: ").Append(MinQty).Append("\n");
            sb.Append("  StopPx: ").Append(StopPx).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as BaseOrder);
        }

        /// <summary>
        /// Returns true if BaseOrder instances are equal
        /// </summary>
        /// <param name="input">Instance of BaseOrder to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BaseOrder input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.OrdType == input.OrdType ||
                    (this.OrdType != null &&
                    this.OrdType.Equals(input.OrdType))
                ) && 
                (
                    this.ClOrdId == input.ClOrdId ||
                    (this.ClOrdId != null &&
                    this.ClOrdId.Equals(input.ClOrdId))
                ) && 
                (
                    this.Symbol == input.Symbol ||
                    (this.Symbol != null &&
                    this.Symbol.Equals(input.Symbol))
                ) && 
                (
                    this.Side == input.Side ||
                    (this.Side != null &&
                    this.Side.Equals(input.Side))
                ) && 
                (
                    this.OrderQty == input.OrderQty ||
                    (this.OrderQty != null &&
                    this.OrderQty.Equals(input.OrderQty))
                ) && 
                (
                    this.TimeInForce == input.TimeInForce ||
                    (this.TimeInForce != null &&
                    this.TimeInForce.Equals(input.TimeInForce))
                ) && 
                (
                    this.Price == input.Price ||
                    (this.Price != null &&
                    this.Price.Equals(input.Price))
                ) && 
                (
                    this.ExpireDate == input.ExpireDate ||
                    (this.ExpireDate != null &&
                    this.ExpireDate.Equals(input.ExpireDate))
                ) && 
                (
                    this.MinQty == input.MinQty ||
                    (this.MinQty != null &&
                    this.MinQty.Equals(input.MinQty))
                ) && 
                (
                    this.StopPx == input.StopPx ||
                    (this.StopPx != null &&
                    this.StopPx.Equals(input.StopPx))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.OrdType != null)
                    hashCode = hashCode * 59 + this.OrdType.GetHashCode();
                if (this.ClOrdId != null)
                    hashCode = hashCode * 59 + this.ClOrdId.GetHashCode();
                if (this.Symbol != null)
                    hashCode = hashCode * 59 + this.Symbol.GetHashCode();
                if (this.Side != null)
                    hashCode = hashCode * 59 + this.Side.GetHashCode();
                if (this.OrderQty != null)
                    hashCode = hashCode * 59 + this.OrderQty.GetHashCode();
                if (this.TimeInForce != null)
                    hashCode = hashCode * 59 + this.TimeInForce.GetHashCode();
                if (this.Price != null)
                    hashCode = hashCode * 59 + this.Price.GetHashCode();
                if (this.ExpireDate != null)
                    hashCode = hashCode * 59 + this.ExpireDate.GetHashCode();
                if (this.MinQty != null)
                    hashCode = hashCode * 59 + this.MinQty.GetHashCode();
                if (this.StopPx != null)
                    hashCode = hashCode * 59 + this.StopPx.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // ClOrdId (string) maxLength
            if(this.ClOrdId != null && this.ClOrdId.Length > 20)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ClOrdId, length must be less than 20.", new [] { "ClOrdId" });
            }

            

            
            // Symbol (string) pattern
            Regex regexSymbol = new Regex(@"^[A-Z]{3,5}-[A-Z]{3,5}$", RegexOptions.CultureInvariant);
            if (false == regexSymbol.Match(this.Symbol).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Symbol, must match a pattern of " + regexSymbol, new [] { "Symbol" });
            }


            
            // ExpireDate (int) maximum
            if(this.ExpireDate > (int)20501231)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExpireDate, must be a value less than or equal to 20501231.", new [] { "ExpireDate" });
            }

            // ExpireDate (int) minimum
            if(this.ExpireDate < (int)20200101)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExpireDate, must be a value greater than or equal to 20200101.", new [] { "ExpireDate" });
            }

            yield break;
        }
    }

}
